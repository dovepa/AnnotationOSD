{"hash":"19abe2aee5dbfc0487cf4ee6fc453707b8740288","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { Injectable, Inject, Component, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\nclass AnnotateMarker {\n    constructor(id, unit, centerY, centerX, width, height, type) {\n        if (unit === 'percent' && (centerX > 1 || centerY > 1 || width > 1 || height > 1)) {\n            throw new Error('AnnotateMarker unit is percent but value > 1');\n        }\n        this.id = id;\n        this.unit = unit;\n        this.centerY = centerY;\n        this.centerX = centerX;\n        this.width = width;\n        this.height = height;\n        this.type = type;\n    }\n}\nclass MarkerRect extends AnnotateMarker {\n    constructor(id, centerY, centerX, width, height, unit = 'percent') {\n        const type = 'MarkerRect';\n        super(id, unit, centerY, centerX, width, height, type);\n    }\n}\nclass MarkerRound extends AnnotateMarker {\n    constructor(id, centerY, centerX, width, height, unit = 'percent') {\n        const type = 'MarkerRound';\n        super(id, unit, centerY, centerX, width, height, type);\n    }\n}\nclass MarkerPoly {\n    constructor(dots, unit = 'percent') {\n        this.type = 'MarkerPoly';\n        this.unit = unit;\n        this.dots = dots;\n    }\n}\n\nclass AnnotationOSDService {\n    constructor(debug = false) {\n        this.DEBUG = debug;\n    }\n    playerFactory(type, id, link) {\n        return new Promise((resolve) => {\n            this.viewer = OpenSeadragon({\n                id,\n                tileSources: type === 'dzi' ? link : { type: 'image', url: link },\n                gestureSettingsTouch: { pinchRotate: false },\n                showRotationControl: false,\n                showNavigationControl: false,\n                showFlipControl: false,\n                zoomPerClick: 1,\n                imageLoaderLimit: 1,\n                constrainDuringPan: true,\n                debugMode: this.DEBUG,\n            });\n            const subjectZoom = new Subject();\n            this.viewer.addHandler('zoom', (e) => {\n                subjectZoom.next(e);\n            });\n            subjectZoom.pipe(debounceTime(50)).subscribe(() => {\n                this.calculateRatio();\n                // this.resetStrokeWidth();\n            });\n            this.viewer.addOnceHandler('open', () => {\n                console.log('open');\n                this.calculateRatio();\n                resolve(this);\n            });\n            const subjectResize = new Subject();\n            this.viewer.addHandler('resize', (e) => {\n                subjectResize.next(e);\n            });\n            subjectResize.pipe(debounceTime(200)).subscribe(() => {\n                this.goHome();\n            });\n        });\n    }\n    //\n    // public setHome(point: Point, width: number, height: number) {\n    //   const homePoint = this.viewer.viewport.imageToViewerElementCoordinates(new OSD.Point(this.imageWidth / 2, this.imageHeight / 2));\n    //   const w = this.imageWidth / width;\n    //   const h = this.imageHeight / height;\n    //   const zoom = 4; // w > h ? h : w;\n    //   console.log(homePoint, zoom, this.imageWidth, this.imageHeight);\n    //   this.viewer.viewport.zoomTo(1.2, homePoint, false);\n    // }\n    // private resetStrokeWidth() {\n    //   if (this.canvas) {\n    //     const w = 2; // desired width in pixels\n    //     const strokeWidth = w / this.canvas.getZoom();\n    //     for (const object of this.canvas.getObjects()) {\n    //       object.set('strokeUniform', true);\n    //       object.set('strokeWidth', strokeWidth);\n    //       if (object.get('radius')) {\n    //         object.set('radius', 5 / this.canvas.getZoom());\n    //       }\n    //       // can also update other things here\n    //     }\n    //   }\n    // }\n    calculateRatio() {\n        // this.imageWidth = this.viewer.source.dimensions.x;\n        // this.imageHeight = this.viewer.source.dimensions.y;\n        // this.containerWidth = this.viewer.viewport.getContainerSize().x;\n        // this.containerHeight = this.viewer.viewport.getContainerSize().y;\n        // this.zoomToZoomLevelRatio = this.containerWidth / this.imageWidth;\n        // this.scale = this.viewer.viewport.getZoom(true) * this.zoomToZoomLevelRatio;\n    }\n    async goHome() {\n        // if (!this.home) this.viewer.viewport.goHome(false);\n        // else this.viewer.viewport.fitBounds(this.home, false);\n        // this.setHome(null, null, null);\n        return this;\n    }\n    addCanvas() {\n        this.canvas = this.viewer\n            .fabricjsOverlay({ scale: 1000 })\n            .fabricCanvas();\n        return this;\n    }\n    addDamage(damage) {\n        const poly = new fabric.Polygon([\n            { x: 200, y: 10 },\n            { x: 250, y: 50 },\n            { x: 250, y: 180 },\n            { x: 150, y: 180 },\n            { x: 150, y: 50 }\n        ], {\n            fill: 'green',\n            opacity: 0.3,\n        });\n        this.canvas.add(poly);\n    }\n}\nAnnotationOSDService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDService, deps: [{ token: Boolean }], target: i0.ɵɵFactoryTarget.Injectable });\nAnnotationOSDService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [Boolean]\n                }] }]; } });\n\nclass AnnotationOSDComponent {\n    constructor() { }\n    ngOnInit() {\n    }\n}\nAnnotationOSDComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nAnnotationOSDComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.7\", type: AnnotationOSDComponent, selector: \"lib-AnnotationOSD\", ngImport: i0, template: `\n    <p>\n      annotation-osd works!\n    </p>\n  `, isInline: true });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDComponent, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'lib-AnnotationOSD',\n                    template: `\n    <p>\n      annotation-osd works!\n    </p>\n  `,\n                    styles: []\n                }]\n        }], ctorParameters: function () { return []; } });\n\nclass AnnotationOSDModule {\n}\nAnnotationOSDModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nAnnotationOSDModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDModule, declarations: [AnnotationOSDComponent] });\nAnnotationOSDModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        AnnotationOSDComponent,\n                    ],\n                    imports: [],\n                }]\n        }] });\n\n/*\n * Public API Surface of annotation-osd\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AnnotationOSDComponent, AnnotationOSDModule, AnnotationOSDService, MarkerPoly, MarkerRect, MarkerRound };\n//# sourceMappingURL=annotation-osd.mjs.map\n","map":{"version":3,"file":"annotation-osd.mjs","sources":["../../../projects/annotation-osd/src/lib/annotation-osd.model.ts","../../../projects/annotation-osd/src/lib/annotation-osd.service.ts","../../../projects/annotation-osd/src/lib/annotation-osd.component.ts","../../../projects/annotation-osd/src/lib/annotation-osd.module.ts","../../../projects/annotation-osd/src/public-api.ts","../../../projects/annotation-osd/src/annotation-osd.ts"],"sourcesContent":["export type PlayerType = 'image' | 'dzi';\nexport type UnitType = 'percent' | 'pixel';\n\nexport interface Point {x : number, y : number}\n\nabstract class AnnotateMarker {\n    readonly id : number;\n    readonly unit : UnitType;\n    readonly centerY : number;\n    readonly centerX : number;\n    readonly width : number;\n    readonly height : number;\n    readonly type : string;\n\n    protected constructor(id: number, unit: UnitType, centerY: number, centerX: number, width: number, height: number, type: string) {\n        if (unit === 'percent' && (centerX > 1 || centerY > 1 || width > 1 || height > 1)) {\n            throw new Error('AnnotateMarker unit is percent but value > 1');\n        }\n        this.id = id;\n        this.unit = unit;\n        this.centerY = centerY;\n        this.centerX = centerX;\n        this.width = width;\n        this.height = height;\n        this.type = type;\n    }\n}\n\nexport class MarkerRect extends AnnotateMarker {\n    constructor(id: number, centerY: number, centerX: number, width: number, height: number, unit: UnitType = 'percent') {\n        const type = 'MarkerRect';\n        super(id, unit, centerY, centerX, width, height, type);\n    }\n}\n\nexport class MarkerRound extends AnnotateMarker {\n    constructor(id: number, centerY: number, centerX: number, width: number, height: number, unit: UnitType = 'percent') {\n        const type = 'MarkerRound';\n        super(id, unit, centerY, centerX, width, height, type);\n    }\n}\n\nexport class MarkerPoly {\n    type = 'MarkerPoly';\n    unit : UnitType;\n    dots : Point[];\n\n    constructor(dots: Point[], unit: UnitType = 'percent') {\n        this.unit = unit;\n        this.dots = dots;\n    }\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport {\n    MarkerPoly, MarkerRect, MarkerRound, PlayerType, Point,\n} from './annotation-osd.model';\n\n// Load type for openseadragon\ndeclare type TypeOpenSeadragon = typeof import('openseadragon');\ndeclare let OpenSeadragon: TypeOpenSeadragon;\n// Load type for fabric\ndeclare type TypeFabric = typeof import('fabric/fabric-impl');\ndeclare let fabric: TypeFabric;\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class AnnotationOSDService {\n    protected viewer: OpenSeadragon.Viewer;\n    protected canvas: fabric.Canvas;\n    protected imageWidth: number;\n    protected imageHeight: number; \n    protected containerWidth: number;\n    protected containerHeight: number;\n    protected zoomToZoomLevelRatio: number;\n    protected scale: number;\n    private readonly DEBUG :boolean;\n\n    constructor(@Inject(Boolean) debug : boolean = false) {\n        this.DEBUG = debug;\n    }\n\n    public playerFactory(type: PlayerType, id: string, link: string): Promise<ThisType<any>> {\n        return new Promise((resolve) => {\n            this.viewer = OpenSeadragon({\n                id,\n                tileSources: type === 'dzi' ? link : { type: 'image', url: link },\n                gestureSettingsTouch: { pinchRotate: false } as OpenSeadragon.GestureSettings,\n                showRotationControl: false,\n                showNavigationControl: false,\n                showFlipControl: false,\n                zoomPerClick: 1,\n                imageLoaderLimit: 1,\n                constrainDuringPan: true,\n                debugMode: this.DEBUG,\n            });\n\n            const subjectZoom: Subject<any> = new Subject();\n            this.viewer.addHandler('zoom', (e: any) => {\n                subjectZoom.next(e);\n            });\n            subjectZoom.pipe(debounceTime(50)).subscribe(() => {\n                this.calculateRatio();\n                // this.resetStrokeWidth();\n            });\n\n\n            this.viewer.addOnceHandler('open', () => {\n                console.log('open');\n                this.calculateRatio();\n                resolve(this);\n            });\n\n            const subjectResize: Subject<any> = new Subject();\n            this.viewer.addHandler('resize', (e: any) => {\n                subjectResize.next(e);\n            });\n            subjectResize.pipe(debounceTime(200)).subscribe(() => {\n                this.goHome();\n            });\n        });\n    }\n    //\n    // public setHome(point: Point, width: number, height: number) {\n    //   const homePoint = this.viewer.viewport.imageToViewerElementCoordinates(new OSD.Point(this.imageWidth / 2, this.imageHeight / 2));\n    //   const w = this.imageWidth / width;\n    //   const h = this.imageHeight / height;\n    //   const zoom = 4; // w > h ? h : w;\n    //   console.log(homePoint, zoom, this.imageWidth, this.imageHeight);\n    //   this.viewer.viewport.zoomTo(1.2, homePoint, false);\n    // }\n\n    // private resetStrokeWidth() {\n    //   if (this.canvas) {\n    //     const w = 2; // desired width in pixels\n    //     const strokeWidth = w / this.canvas.getZoom();\n    //     for (const object of this.canvas.getObjects()) {\n    //       object.set('strokeUniform', true);\n    //       object.set('strokeWidth', strokeWidth);\n    //       if (object.get('radius')) {\n    //         object.set('radius', 5 / this.canvas.getZoom());\n    //       }\n    //       // can also update other things here\n    //     }\n    //   }\n    // }\n\n    private calculateRatio() {\n    // this.imageWidth = this.viewer.source.dimensions.x;\n    // this.imageHeight = this.viewer.source.dimensions.y;\n    // this.containerWidth = this.viewer.viewport.getContainerSize().x;\n    // this.containerHeight = this.viewer.viewport.getContainerSize().y;\n    // this.zoomToZoomLevelRatio = this.containerWidth / this.imageWidth;\n    // this.scale = this.viewer.viewport.getZoom(true) * this.zoomToZoomLevelRatio;\n    }\n\n    public async goHome() {\n    // if (!this.home) this.viewer.viewport.goHome(false);\n    // else this.viewer.viewport.fitBounds(this.home, false);\n    // this.setHome(null, null, null);\n        return this;\n    }\n\n    public addCanvas() {\n        this.canvas = (this.viewer as any)\n            .fabricjsOverlay({ scale: 1000 })\n            .fabricCanvas();\n        return this;\n    }\n\n    public addDamage(damage : MarkerRound | MarkerRect | MarkerPoly) {\n        const poly = new fabric.Polygon([\n            { x: 200, y: 10 },\n            { x: 250, y: 50 },\n            { x: 250, y: 180 },\n            { x: 150, y: 180 },\n            { x: 150, y: 50 }], {\n            fill: 'green',\n            opacity: 0.3,\n        });\n\n        this.canvas.add(poly);\n    }\n    /*\n    min = 99;\n    max = 999999;\n    polygonMode = true;\n    pointArray = [];\n    lineArray = [];\n    activeLine;\n    activeShape ;\n\n    public addDamage(damage : MarkerRound | MarkerRect | MarkerPoly) {\n  const strokeWidth = 2;\n  let obj;\n  if (!(damage instanceof MarkerPoly)) {\n  obj = new fabric.Rect({\n  id: 1,\n  left: (damage.unit === 'percent' ? damage.centerX * (this.imageWidth * this.scale)\n  : damage.centerX * this.scale) + strokeWidth,\n  top: (damage.unit === 'percent' ? damage.centerY * (this.imageHeight * this.scale)\n  : damage.centerY * this.scale) + strokeWidth,\n  width: (damage.unit === 'percent' ? damage.width * (this.imageWidth * this.scale)\n  : damage.width * this.scale),\n  height: (damage.unit === 'percent' ? damage.height * (this.imageHeight * this.scale)\n  : damage.height * this.scale),\n  strokeWidth,\n  strokeUniform: true,\n  strokeDashArray: undefined,\n  originX: 'center',\n  originY: 'center',\n  cornerStyle: 'circle',\n\n  // Add data option for style settings\n  fill: 'transparent',\n  stroke: 'red',\n  selectable: true,\n  hasBorders: false,\n  cornerColor: 'red',\n  transparentCorners: false,\n  draggable: true,\n  lockRotation: true,\n  hasControls: true,\n\n  });\n  }\n  obj.set('strokeUniform', true);\n\n  obj.setControlsVisibility({ mtr: false });\n  this.canvas.add(obj);\n\n  const poly = new fabric.Polygon([\n  { x: 200, y: 10 },\n  { x: 250, y: 50 },\n  { x: 250, y: 180 },\n  { x: 150, y: 180 },\n  { x: 150, y: 50 }], {\n      fill: 'green',\n          opacity: 0.3,\n          });\n\n  this.canvas.add(poly);\n\n  // this.canvas.on('mouse:down', (options) => {\n  //     if (options.target && options.target.id === this.pointArray[0].id) {\n  //         this.generatePolygon(this.pointArray);\n  //     }\n  //     if (this.polygonMode) {\n  //         this.addPoint(options);\n  //     }\n  // });\n  // this.canvas.on('mouse:up', (options) => {\n  //\n  // });\n  // this.canvas.on('mouse:move', (options) => {\n  //     if (this.activeLine && this.activeLine.class === 'line') {\n  //         const pointer = this.canvas.getPointer(options.e);\n  //         this.activeLine.set({ x2: pointer.x, y2: pointer.y });\n  //\n  //         const points = this.activeShape.get('points');\n  //         points[this.pointArray.length] = {\n  //             x: pointer.x,\n  //             y: pointer.y,\n  //         };\n  //         this.activeShape.set({\n  //             points,\n  //         });\n  //         this.canvas.renderAll();\n  //     }\n  //     this.canvas.renderAll();\n  // });\n\n  /!*        this.canvas.on('object:scaling', (e) => {\n  console.log('scalling ');\n  this.resetStrokeWidth();\n  }); *!/\n  return this;\n  }\n\n  private drawPolygon() {\n  this.polygonMode = true;\n  this.pointArray = [];\n  this.lineArray = [];\n  this.activeLine;\n  }\n\n  private addPoint(options) {\n  console.log(options);\n  const random = Math.floor(Math.random() * (this.max - this.min + 1)) + this.min;\n  const id = new Date().getTime() + random;\n  const pos = this.canvas.getPointer(options.e);\n  const circle = new fabric.Circle({\n  radius: 5 / this.canvas.getZoom(),\n  fill: '#ffffff',\n  stroke: '#333333',\n  strokeWidth: 0.5,\n  left: pos.x,\n  top: pos.y,\n  selectable: false,\n  hasBorders: false,\n  hasControls: false,\n  originX: 'center',\n  originY: 'center',\n  id,\n  objectCaching: false,\n  });\n  if (this.pointArray.length === 0) {\n  circle.set({\n  fill: 'red',\n  });\n  }\n  const pointsA = [pos.x, pos.y, pos.x, pos.y];\n  const line = new fabric.Line(pointsA, {\n  strokeWidth: 2,\n  fill: '#999999',\n  stroke: '#999999',\n  class: 'line',\n  originX: 'center',\n  originY: 'center',\n  selectable: false,\n  hasBorders: false,\n  hasControls: false,\n  evented: false,\n  objectCaching: false,\n  });\n  console.log(this.activeShape);\n  if (this.activeShape) {\n      const pointsB = this.activeShape.get('points') as any[];\n          pointsB.push({\n              x: pos.x,\n              y: pos.y,\n          });\n          const polygonA = new fabric.Polygon(pointsB, {\n      stroke: '#333333',\n      strokeWidth: 1,\n      fill: '#cccccc',\n      opacity: 0.3,\n      selectable: false,\n      hasBorders: false,\n      hasControls: false,\n      evented: false,\n      objectCaching: false,\n    });\n    this.canvas.remove(this.activeShape);\n    this.canvas.add(polygonA);\n    this.activeShape = polygonA;\n    this.canvas.renderAll();\n  } else {\n    const polyPoint = [{ x: pos.x, y: pos.y }];\n    const polygon = new fabric.Polygon(polyPoint, {\n          stroke: '#333333',\n                  strokeWidth: 1,\n                  fill: '#cccccc',\n                  opacity: 0.3,\n                  selectable: false,\n                  hasBorders: false,\n                  hasControls: false,\n                  evented: false,\n                  objectCaching: false,\n          });\n          this.activeShape = polygon;\n          this.canvas.add(polygon);\n          }\n  this.activeLine = line;\n\n  this.pointArray.push(circle);\n  this.lineArray.push(line);\n\n  this.canvas.add(line);\n  this.canvas.add(circle);\n  }\n\n  private generatePolygon(pointArray) {\n  console.log(pointArray, this.lineArray);\n  const points = [];\n  pointArray.forEach((point) => {\n  points.push({\n  x: point.left,\n  y: point.top,\n  });\n    this.canvas.remove(point);\n  });\n  this.lineArray.forEach((line) => {\n  this.canvas.remove(line);\n  });\n  this.canvas.remove(this.activeShape).remove(this.activeLine);\n  const polygon = new fabric.Polygon(points, {\n  stroke: '#333333',\n  strokeWidth: 0.5,\n  opacity: 0.3,\n  fill: 'red',\n  hasBorders: false,\n  hasControls: false,\n  });\n  this.canvas.add(polygon);\n\n  this.activeLine = null;\n  this.activeShape = null;\n  this.polygonMode = false;\n  }\n\n  public delete() {\n  this.canvas.clear();\n  this.canvas.dispose();\n  this.canvas.removeListeners();\n  this.viewer.destroy();\n  }*/\n}","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'lib-AnnotationOSD',\n  template: `\n    <p>\n      annotation-osd works!\n    </p>\n  `,\n  styles: [\n  ]\n})\nexport class AnnotationOSDComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { AnnotationOSDComponent } from './annotation-osd.component';\n\n@NgModule({\n    declarations: [\n        AnnotationOSDComponent,\n    ],\n    imports: [\n    ],\n})\nexport class AnnotationOSDModule { }\n","/*\n * Public API Surface of annotation-osd\n */\n\nexport * from './lib/annotation-osd.model';\nexport * from './lib/annotation-osd.service';\nexport * from './lib/annotation-osd.component';\nexport * from './lib/annotation-osd.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}},"fesm2015":{"code":"import { __awaiter } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, Component, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\nclass AnnotateMarker {\n    constructor(id, unit, centerY, centerX, width, height, type) {\n        if (unit === 'percent' && (centerX > 1 || centerY > 1 || width > 1 || height > 1)) {\n            throw new Error('AnnotateMarker unit is percent but value > 1');\n        }\n        this.id = id;\n        this.unit = unit;\n        this.centerY = centerY;\n        this.centerX = centerX;\n        this.width = width;\n        this.height = height;\n        this.type = type;\n    }\n}\nclass MarkerRect extends AnnotateMarker {\n    constructor(id, centerY, centerX, width, height, unit = 'percent') {\n        const type = 'MarkerRect';\n        super(id, unit, centerY, centerX, width, height, type);\n    }\n}\nclass MarkerRound extends AnnotateMarker {\n    constructor(id, centerY, centerX, width, height, unit = 'percent') {\n        const type = 'MarkerRound';\n        super(id, unit, centerY, centerX, width, height, type);\n    }\n}\nclass MarkerPoly {\n    constructor(dots, unit = 'percent') {\n        this.type = 'MarkerPoly';\n        this.unit = unit;\n        this.dots = dots;\n    }\n}\n\nclass AnnotationOSDService {\n    constructor(debug = false) {\n        this.DEBUG = debug;\n    }\n    playerFactory(type, id, link) {\n        return new Promise((resolve) => {\n            this.viewer = OpenSeadragon({\n                id,\n                tileSources: type === 'dzi' ? link : { type: 'image', url: link },\n                gestureSettingsTouch: { pinchRotate: false },\n                showRotationControl: false,\n                showNavigationControl: false,\n                showFlipControl: false,\n                zoomPerClick: 1,\n                imageLoaderLimit: 1,\n                constrainDuringPan: true,\n                debugMode: this.DEBUG,\n            });\n            const subjectZoom = new Subject();\n            this.viewer.addHandler('zoom', (e) => {\n                subjectZoom.next(e);\n            });\n            subjectZoom.pipe(debounceTime(50)).subscribe(() => {\n                this.calculateRatio();\n                // this.resetStrokeWidth();\n            });\n            this.viewer.addOnceHandler('open', () => {\n                console.log('open');\n                this.calculateRatio();\n                resolve(this);\n            });\n            const subjectResize = new Subject();\n            this.viewer.addHandler('resize', (e) => {\n                subjectResize.next(e);\n            });\n            subjectResize.pipe(debounceTime(200)).subscribe(() => {\n                this.goHome();\n            });\n        });\n    }\n    //\n    // public setHome(point: Point, width: number, height: number) {\n    //   const homePoint = this.viewer.viewport.imageToViewerElementCoordinates(new OSD.Point(this.imageWidth / 2, this.imageHeight / 2));\n    //   const w = this.imageWidth / width;\n    //   const h = this.imageHeight / height;\n    //   const zoom = 4; // w > h ? h : w;\n    //   console.log(homePoint, zoom, this.imageWidth, this.imageHeight);\n    //   this.viewer.viewport.zoomTo(1.2, homePoint, false);\n    // }\n    // private resetStrokeWidth() {\n    //   if (this.canvas) {\n    //     const w = 2; // desired width in pixels\n    //     const strokeWidth = w / this.canvas.getZoom();\n    //     for (const object of this.canvas.getObjects()) {\n    //       object.set('strokeUniform', true);\n    //       object.set('strokeWidth', strokeWidth);\n    //       if (object.get('radius')) {\n    //         object.set('radius', 5 / this.canvas.getZoom());\n    //       }\n    //       // can also update other things here\n    //     }\n    //   }\n    // }\n    calculateRatio() {\n        // this.imageWidth = this.viewer.source.dimensions.x;\n        // this.imageHeight = this.viewer.source.dimensions.y;\n        // this.containerWidth = this.viewer.viewport.getContainerSize().x;\n        // this.containerHeight = this.viewer.viewport.getContainerSize().y;\n        // this.zoomToZoomLevelRatio = this.containerWidth / this.imageWidth;\n        // this.scale = this.viewer.viewport.getZoom(true) * this.zoomToZoomLevelRatio;\n    }\n    goHome() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // if (!this.home) this.viewer.viewport.goHome(false);\n            // else this.viewer.viewport.fitBounds(this.home, false);\n            // this.setHome(null, null, null);\n            return this;\n        });\n    }\n    addCanvas() {\n        this.canvas = this.viewer\n            .fabricjsOverlay({ scale: 1000 })\n            .fabricCanvas();\n        return this;\n    }\n    addDamage(damage) {\n        const poly = new fabric.Polygon([\n            { x: 200, y: 10 },\n            { x: 250, y: 50 },\n            { x: 250, y: 180 },\n            { x: 150, y: 180 },\n            { x: 150, y: 50 }\n        ], {\n            fill: 'green',\n            opacity: 0.3,\n        });\n        this.canvas.add(poly);\n    }\n}\nAnnotationOSDService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDService, deps: [{ token: Boolean }], target: i0.ɵɵFactoryTarget.Injectable });\nAnnotationOSDService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [Boolean]\n                    }] }];\n    } });\n\nclass AnnotationOSDComponent {\n    constructor() { }\n    ngOnInit() {\n    }\n}\nAnnotationOSDComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nAnnotationOSDComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.7\", type: AnnotationOSDComponent, selector: \"lib-AnnotationOSD\", ngImport: i0, template: `\n    <p>\n      annotation-osd works!\n    </p>\n  `, isInline: true });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDComponent, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'lib-AnnotationOSD',\n                    template: `\n    <p>\n      annotation-osd works!\n    </p>\n  `,\n                    styles: []\n                }]\n        }], ctorParameters: function () { return []; } });\n\nclass AnnotationOSDModule {\n}\nAnnotationOSDModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nAnnotationOSDModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDModule, declarations: [AnnotationOSDComponent] });\nAnnotationOSDModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: AnnotationOSDModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        AnnotationOSDComponent,\n                    ],\n                    imports: [],\n                }]\n        }] });\n\n/*\n * Public API Surface of annotation-osd\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AnnotationOSDComponent, AnnotationOSDModule, AnnotationOSDService, MarkerPoly, MarkerRect, MarkerRound };\n//# sourceMappingURL=annotation-osd.mjs.map\n","map":{"version":3,"file":"annotation-osd.mjs","sources":["../../../projects/annotation-osd/src/lib/annotation-osd.model.ts","../../../projects/annotation-osd/src/lib/annotation-osd.service.ts","../../../projects/annotation-osd/src/lib/annotation-osd.component.ts","../../../projects/annotation-osd/src/lib/annotation-osd.module.ts","../../../projects/annotation-osd/src/public-api.ts","../../../projects/annotation-osd/src/annotation-osd.ts"],"sourcesContent":["export type PlayerType = 'image' | 'dzi';\nexport type UnitType = 'percent' | 'pixel';\n\nexport interface Point {x : number, y : number}\n\nabstract class AnnotateMarker {\n    readonly id : number;\n    readonly unit : UnitType;\n    readonly centerY : number;\n    readonly centerX : number;\n    readonly width : number;\n    readonly height : number;\n    readonly type : string;\n\n    protected constructor(id: number, unit: UnitType, centerY: number, centerX: number, width: number, height: number, type: string) {\n        if (unit === 'percent' && (centerX > 1 || centerY > 1 || width > 1 || height > 1)) {\n            throw new Error('AnnotateMarker unit is percent but value > 1');\n        }\n        this.id = id;\n        this.unit = unit;\n        this.centerY = centerY;\n        this.centerX = centerX;\n        this.width = width;\n        this.height = height;\n        this.type = type;\n    }\n}\n\nexport class MarkerRect extends AnnotateMarker {\n    constructor(id: number, centerY: number, centerX: number, width: number, height: number, unit: UnitType = 'percent') {\n        const type = 'MarkerRect';\n        super(id, unit, centerY, centerX, width, height, type);\n    }\n}\n\nexport class MarkerRound extends AnnotateMarker {\n    constructor(id: number, centerY: number, centerX: number, width: number, height: number, unit: UnitType = 'percent') {\n        const type = 'MarkerRound';\n        super(id, unit, centerY, centerX, width, height, type);\n    }\n}\n\nexport class MarkerPoly {\n    type = 'MarkerPoly';\n    unit : UnitType;\n    dots : Point[];\n\n    constructor(dots: Point[], unit: UnitType = 'percent') {\n        this.unit = unit;\n        this.dots = dots;\n    }\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport {\n    MarkerPoly, MarkerRect, MarkerRound, PlayerType, Point,\n} from './annotation-osd.model';\n\n// Load type for openseadragon\ndeclare type TypeOpenSeadragon = typeof import('openseadragon');\ndeclare let OpenSeadragon: TypeOpenSeadragon;\n// Load type for fabric\ndeclare type TypeFabric = typeof import('fabric/fabric-impl');\ndeclare let fabric: TypeFabric;\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class AnnotationOSDService {\n    protected viewer: OpenSeadragon.Viewer;\n    protected canvas: fabric.Canvas;\n    protected imageWidth: number;\n    protected imageHeight: number; \n    protected containerWidth: number;\n    protected containerHeight: number;\n    protected zoomToZoomLevelRatio: number;\n    protected scale: number;\n    private readonly DEBUG :boolean;\n\n    constructor(@Inject(Boolean) debug : boolean = false) {\n        this.DEBUG = debug;\n    }\n\n    public playerFactory(type: PlayerType, id: string, link: string): Promise<ThisType<any>> {\n        return new Promise((resolve) => {\n            this.viewer = OpenSeadragon({\n                id,\n                tileSources: type === 'dzi' ? link : { type: 'image', url: link },\n                gestureSettingsTouch: { pinchRotate: false } as OpenSeadragon.GestureSettings,\n                showRotationControl: false,\n                showNavigationControl: false,\n                showFlipControl: false,\n                zoomPerClick: 1,\n                imageLoaderLimit: 1,\n                constrainDuringPan: true,\n                debugMode: this.DEBUG,\n            });\n\n            const subjectZoom: Subject<any> = new Subject();\n            this.viewer.addHandler('zoom', (e: any) => {\n                subjectZoom.next(e);\n            });\n            subjectZoom.pipe(debounceTime(50)).subscribe(() => {\n                this.calculateRatio();\n                // this.resetStrokeWidth();\n            });\n\n\n            this.viewer.addOnceHandler('open', () => {\n                console.log('open');\n                this.calculateRatio();\n                resolve(this);\n            });\n\n            const subjectResize: Subject<any> = new Subject();\n            this.viewer.addHandler('resize', (e: any) => {\n                subjectResize.next(e);\n            });\n            subjectResize.pipe(debounceTime(200)).subscribe(() => {\n                this.goHome();\n            });\n        });\n    }\n    //\n    // public setHome(point: Point, width: number, height: number) {\n    //   const homePoint = this.viewer.viewport.imageToViewerElementCoordinates(new OSD.Point(this.imageWidth / 2, this.imageHeight / 2));\n    //   const w = this.imageWidth / width;\n    //   const h = this.imageHeight / height;\n    //   const zoom = 4; // w > h ? h : w;\n    //   console.log(homePoint, zoom, this.imageWidth, this.imageHeight);\n    //   this.viewer.viewport.zoomTo(1.2, homePoint, false);\n    // }\n\n    // private resetStrokeWidth() {\n    //   if (this.canvas) {\n    //     const w = 2; // desired width in pixels\n    //     const strokeWidth = w / this.canvas.getZoom();\n    //     for (const object of this.canvas.getObjects()) {\n    //       object.set('strokeUniform', true);\n    //       object.set('strokeWidth', strokeWidth);\n    //       if (object.get('radius')) {\n    //         object.set('radius', 5 / this.canvas.getZoom());\n    //       }\n    //       // can also update other things here\n    //     }\n    //   }\n    // }\n\n    private calculateRatio() {\n    // this.imageWidth = this.viewer.source.dimensions.x;\n    // this.imageHeight = this.viewer.source.dimensions.y;\n    // this.containerWidth = this.viewer.viewport.getContainerSize().x;\n    // this.containerHeight = this.viewer.viewport.getContainerSize().y;\n    // this.zoomToZoomLevelRatio = this.containerWidth / this.imageWidth;\n    // this.scale = this.viewer.viewport.getZoom(true) * this.zoomToZoomLevelRatio;\n    }\n\n    public async goHome() {\n    // if (!this.home) this.viewer.viewport.goHome(false);\n    // else this.viewer.viewport.fitBounds(this.home, false);\n    // this.setHome(null, null, null);\n        return this;\n    }\n\n    public addCanvas() {\n        this.canvas = (this.viewer as any)\n            .fabricjsOverlay({ scale: 1000 })\n            .fabricCanvas();\n        return this;\n    }\n\n    public addDamage(damage : MarkerRound | MarkerRect | MarkerPoly) {\n        const poly = new fabric.Polygon([\n            { x: 200, y: 10 },\n            { x: 250, y: 50 },\n            { x: 250, y: 180 },\n            { x: 150, y: 180 },\n            { x: 150, y: 50 }], {\n            fill: 'green',\n            opacity: 0.3,\n        });\n\n        this.canvas.add(poly);\n    }\n    /*\n    min = 99;\n    max = 999999;\n    polygonMode = true;\n    pointArray = [];\n    lineArray = [];\n    activeLine;\n    activeShape ;\n\n    public addDamage(damage : MarkerRound | MarkerRect | MarkerPoly) {\n  const strokeWidth = 2;\n  let obj;\n  if (!(damage instanceof MarkerPoly)) {\n  obj = new fabric.Rect({\n  id: 1,\n  left: (damage.unit === 'percent' ? damage.centerX * (this.imageWidth * this.scale)\n  : damage.centerX * this.scale) + strokeWidth,\n  top: (damage.unit === 'percent' ? damage.centerY * (this.imageHeight * this.scale)\n  : damage.centerY * this.scale) + strokeWidth,\n  width: (damage.unit === 'percent' ? damage.width * (this.imageWidth * this.scale)\n  : damage.width * this.scale),\n  height: (damage.unit === 'percent' ? damage.height * (this.imageHeight * this.scale)\n  : damage.height * this.scale),\n  strokeWidth,\n  strokeUniform: true,\n  strokeDashArray: undefined,\n  originX: 'center',\n  originY: 'center',\n  cornerStyle: 'circle',\n\n  // Add data option for style settings\n  fill: 'transparent',\n  stroke: 'red',\n  selectable: true,\n  hasBorders: false,\n  cornerColor: 'red',\n  transparentCorners: false,\n  draggable: true,\n  lockRotation: true,\n  hasControls: true,\n\n  });\n  }\n  obj.set('strokeUniform', true);\n\n  obj.setControlsVisibility({ mtr: false });\n  this.canvas.add(obj);\n\n  const poly = new fabric.Polygon([\n  { x: 200, y: 10 },\n  { x: 250, y: 50 },\n  { x: 250, y: 180 },\n  { x: 150, y: 180 },\n  { x: 150, y: 50 }], {\n      fill: 'green',\n          opacity: 0.3,\n          });\n\n  this.canvas.add(poly);\n\n  // this.canvas.on('mouse:down', (options) => {\n  //     if (options.target && options.target.id === this.pointArray[0].id) {\n  //         this.generatePolygon(this.pointArray);\n  //     }\n  //     if (this.polygonMode) {\n  //         this.addPoint(options);\n  //     }\n  // });\n  // this.canvas.on('mouse:up', (options) => {\n  //\n  // });\n  // this.canvas.on('mouse:move', (options) => {\n  //     if (this.activeLine && this.activeLine.class === 'line') {\n  //         const pointer = this.canvas.getPointer(options.e);\n  //         this.activeLine.set({ x2: pointer.x, y2: pointer.y });\n  //\n  //         const points = this.activeShape.get('points');\n  //         points[this.pointArray.length] = {\n  //             x: pointer.x,\n  //             y: pointer.y,\n  //         };\n  //         this.activeShape.set({\n  //             points,\n  //         });\n  //         this.canvas.renderAll();\n  //     }\n  //     this.canvas.renderAll();\n  // });\n\n  /!*        this.canvas.on('object:scaling', (e) => {\n  console.log('scalling ');\n  this.resetStrokeWidth();\n  }); *!/\n  return this;\n  }\n\n  private drawPolygon() {\n  this.polygonMode = true;\n  this.pointArray = [];\n  this.lineArray = [];\n  this.activeLine;\n  }\n\n  private addPoint(options) {\n  console.log(options);\n  const random = Math.floor(Math.random() * (this.max - this.min + 1)) + this.min;\n  const id = new Date().getTime() + random;\n  const pos = this.canvas.getPointer(options.e);\n  const circle = new fabric.Circle({\n  radius: 5 / this.canvas.getZoom(),\n  fill: '#ffffff',\n  stroke: '#333333',\n  strokeWidth: 0.5,\n  left: pos.x,\n  top: pos.y,\n  selectable: false,\n  hasBorders: false,\n  hasControls: false,\n  originX: 'center',\n  originY: 'center',\n  id,\n  objectCaching: false,\n  });\n  if (this.pointArray.length === 0) {\n  circle.set({\n  fill: 'red',\n  });\n  }\n  const pointsA = [pos.x, pos.y, pos.x, pos.y];\n  const line = new fabric.Line(pointsA, {\n  strokeWidth: 2,\n  fill: '#999999',\n  stroke: '#999999',\n  class: 'line',\n  originX: 'center',\n  originY: 'center',\n  selectable: false,\n  hasBorders: false,\n  hasControls: false,\n  evented: false,\n  objectCaching: false,\n  });\n  console.log(this.activeShape);\n  if (this.activeShape) {\n      const pointsB = this.activeShape.get('points') as any[];\n          pointsB.push({\n              x: pos.x,\n              y: pos.y,\n          });\n          const polygonA = new fabric.Polygon(pointsB, {\n      stroke: '#333333',\n      strokeWidth: 1,\n      fill: '#cccccc',\n      opacity: 0.3,\n      selectable: false,\n      hasBorders: false,\n      hasControls: false,\n      evented: false,\n      objectCaching: false,\n    });\n    this.canvas.remove(this.activeShape);\n    this.canvas.add(polygonA);\n    this.activeShape = polygonA;\n    this.canvas.renderAll();\n  } else {\n    const polyPoint = [{ x: pos.x, y: pos.y }];\n    const polygon = new fabric.Polygon(polyPoint, {\n          stroke: '#333333',\n                  strokeWidth: 1,\n                  fill: '#cccccc',\n                  opacity: 0.3,\n                  selectable: false,\n                  hasBorders: false,\n                  hasControls: false,\n                  evented: false,\n                  objectCaching: false,\n          });\n          this.activeShape = polygon;\n          this.canvas.add(polygon);\n          }\n  this.activeLine = line;\n\n  this.pointArray.push(circle);\n  this.lineArray.push(line);\n\n  this.canvas.add(line);\n  this.canvas.add(circle);\n  }\n\n  private generatePolygon(pointArray) {\n  console.log(pointArray, this.lineArray);\n  const points = [];\n  pointArray.forEach((point) => {\n  points.push({\n  x: point.left,\n  y: point.top,\n  });\n    this.canvas.remove(point);\n  });\n  this.lineArray.forEach((line) => {\n  this.canvas.remove(line);\n  });\n  this.canvas.remove(this.activeShape).remove(this.activeLine);\n  const polygon = new fabric.Polygon(points, {\n  stroke: '#333333',\n  strokeWidth: 0.5,\n  opacity: 0.3,\n  fill: 'red',\n  hasBorders: false,\n  hasControls: false,\n  });\n  this.canvas.add(polygon);\n\n  this.activeLine = null;\n  this.activeShape = null;\n  this.polygonMode = false;\n  }\n\n  public delete() {\n  this.canvas.clear();\n  this.canvas.dispose();\n  this.canvas.removeListeners();\n  this.viewer.destroy();\n  }*/\n}","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'lib-AnnotationOSD',\n  template: `\n    <p>\n      annotation-osd works!\n    </p>\n  `,\n  styles: [\n  ]\n})\nexport class AnnotationOSDComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { AnnotationOSDComponent } from './annotation-osd.component';\n\n@NgModule({\n    declarations: [\n        AnnotationOSDComponent,\n    ],\n    imports: [\n    ],\n})\nexport class AnnotationOSDModule { }\n","/*\n * Public API Surface of annotation-osd\n */\n\nexport * from './lib/annotation-osd.model';\nexport * from './lib/annotation-osd.service';\nexport * from './lib/annotation-osd.component';\nexport * from './lib/annotation-osd.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}}}