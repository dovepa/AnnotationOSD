{"ast":null,"code":"\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\nconst {\n  spawnSync\n} = require(\"child_process\");\nconst {\n  URL\n} = require(\"whatwg-url\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst tough = require(\"tough-cookie\");\nconst MIMEType = require(\"whatwg-mimetype\");\nconst xhrUtils = require(\"./xhr-utils\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst {\n  documentBaseURLSerialized\n} = require(\"../helpers/document-base-url\");\nconst {\n  asciiCaseInsensitiveMatch\n} = require(\"../helpers/strings\");\nconst idlUtils = require(\"../generated/utils\");\nconst Document = require(\"../generated/Document\");\nconst Blob = require(\"../generated/Blob\");\nconst FormData = require(\"../generated/FormData\");\nconst XMLHttpRequestEventTargetImpl = require(\"./XMLHttpRequestEventTarget-impl\").implementation;\nconst XMLHttpRequestUpload = require(\"../generated/XMLHttpRequestUpload\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst {\n  isArrayBuffer\n} = require(\"../generated/utils\");\nconst {\n  parseIntoDocument\n} = require(\"../../browser/parser\");\nconst {\n  fragmentSerialization\n} = require(\"../domparsing/serialization\");\nconst {\n  setupForSimpleEventAccessors\n} = require(\"../helpers/create-event-accessor\");\nconst {\n  parseJSONFromBytes\n} = require(\"../helpers/json\");\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\nconst {\n  copyToArrayBufferInNewRealm\n} = require(\"../helpers/binary-data\");\nconst {\n  READY_STATES\n} = xhrUtils;\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\nconst forbiddenRequestHeaders = new Set([\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"cookie\", \"cookie2\", \"date\", \"dnt\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]);\nconst forbiddenResponseHeaders = new Set([\"set-cookie\", \"set-cookie2\"]);\nconst uniqueResponseHeaders = new Set([\"content-type\", \"content-length\", \"user-agent\", \"referer\", \"host\", \"authorization\", \"proxy-authorization\", \"if-modified-since\", \"if-unmodified-since\", \"from\", \"location\", \"max-forwards\"]);\nconst corsSafeResponseHeaders = new Set([\"cache-control\", \"content-language\", \"content-length\", \"content-type\", \"expires\", \"last-modified\", \"pragma\"]);\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\nclass XMLHttpRequestImpl extends XMLHttpRequestEventTargetImpl {\n  constructor(window) {\n    super(window);\n\n    // Avoid running `_ownerDocument` getter multiple times in the constructor:\n    const {\n      _ownerDocument\n    } = this;\n    this.upload = XMLHttpRequestUpload.createImpl(window);\n    this.readyState = READY_STATES.UNSENT;\n    this.responseURL = \"\";\n    this.status = 0;\n    this.statusText = \"\";\n    this.flag = {\n      synchronous: false,\n      withCredentials: false,\n      mimeType: null,\n      auth: null,\n      method: undefined,\n      responseType: \"\",\n      requestHeaders: {},\n      referrer: _ownerDocument.URL,\n      uri: \"\",\n      timeout: 0,\n      body: undefined,\n      formData: false,\n      preflight: false,\n      requestManager: _ownerDocument._requestManager,\n      strictSSL: window._resourceLoader._strictSSL,\n      proxy: window._resourceLoader._proxy,\n      cookieJar: _ownerDocument._cookieJar,\n      encoding: _ownerDocument._encoding,\n      origin: window._origin,\n      userAgent: window.navigator.userAgent\n    };\n    this.properties = {\n      beforeSend: false,\n      send: false,\n      client: null,\n      timeoutStart: 0,\n      timeoutId: 0,\n      timeoutFn: null,\n      responseBuffer: null,\n      responseCache: null,\n      responseTextCache: null,\n      responseXMLCache: null,\n      responseHeaders: {},\n      filteredResponseHeaders: [],\n      error: \"\",\n      uploadComplete: false,\n      uploadListener: false,\n      // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n      // In that case the termination reason is \"fatal\", not \"end-user abort\".\n      abortError: false,\n      cookieJar: _ownerDocument._cookieJar,\n      bufferStepSize: 1 * 1024 * 1024,\n      // pre-allocate buffer increase step size. init value is 1MB\n      totalReceivedChunkSize: 0\n    };\n  }\n  get responseType() {\n    return this.flag.responseType;\n  }\n  set responseType(responseType) {\n    const {\n      flag\n    } = this;\n    if (this.readyState === READY_STATES.LOADING || this.readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState === READY_STATES.OPENED && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n    flag.responseType = responseType;\n  }\n  get response() {\n    const {\n      properties\n    } = this;\n    if (properties.responseCache) {\n      // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n      return idlUtils.tryWrapperForImpl(properties.responseCache);\n    }\n    let res;\n    const responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n    switch (this.responseType) {\n      case \"\":\n      case \"text\":\n        {\n          res = this.responseText;\n          break;\n        }\n      case \"arraybuffer\":\n        {\n          if (!responseBuffer) {\n            return null;\n          }\n          res = copyToArrayBufferInNewRealm(responseBuffer, this._globalObject);\n          break;\n        }\n      case \"blob\":\n        {\n          if (!responseBuffer) {\n            return null;\n          }\n          const contentType = finalMIMEType(this);\n          res = Blob.createImpl(this._globalObject, [[new Uint8Array(responseBuffer)], {\n            type: contentType || \"\"\n          }]);\n          break;\n        }\n      case \"document\":\n        {\n          res = this.responseXML;\n          break;\n        }\n      case \"json\":\n        {\n          if (this.readyState !== READY_STATES.DONE || !responseBuffer) {\n            res = null;\n          }\n          try {\n            res = parseJSONFromBytes(responseBuffer);\n          } catch (e) {\n            res = null;\n          }\n          break;\n        }\n    }\n    properties.responseCache = res;\n    // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n    return idlUtils.tryWrapperForImpl(res);\n  }\n  get responseText() {\n    const {\n      properties\n    } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"text\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.LOADING && this.readyState !== READY_STATES.DONE) {\n      return \"\";\n    }\n    if (properties.responseTextCache) {\n      return properties.responseTextCache;\n    }\n    const responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n    if (!responseBuffer) {\n      return \"\";\n    }\n    const fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n    properties.responseTextCache = res;\n    return res;\n  }\n  get responseXML() {\n    const {\n      flag,\n      properties\n    } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"document\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.DONE) {\n      return null;\n    }\n    if (properties.responseXMLCache) {\n      return properties.responseXMLCache;\n    }\n    const responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n    if (!responseBuffer) {\n      return null;\n    }\n    const contentType = finalMIMEType(this);\n    let isHTML = false;\n    let isXML = false;\n    const parsed = MIMEType.parse(contentType);\n    if (parsed) {\n      isHTML = parsed.isHTML();\n      isXML = parsed.isXML();\n      if (!isXML && !isHTML) {\n        return null;\n      }\n    }\n    if (this.responseType === \"\" && isHTML) {\n      return null;\n    }\n    const encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const resText = whatwgEncoding.decode(responseBuffer, encoding);\n    if (!resText) {\n      return null;\n    }\n    const res = Document.createImpl(this._globalObject, [], {\n      options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: {\n          setCookieSync: () => undefined,\n          getCookieStringSync: () => \"\"\n        },\n        encoding,\n        parseOptions: this._ownerDocument._parseOptions\n      }\n    });\n    try {\n      parseIntoDocument(resText, res);\n    } catch (e) {\n      properties.responseXMLCache = null;\n      return null;\n    }\n    res.close();\n    properties.responseXMLCache = res;\n    return res;\n  }\n  get timeout() {\n    return this.flag.timeout;\n  }\n  set timeout(val) {\n    const {\n      flag,\n      properties\n    } = this;\n    if (flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n    flag.timeout = val;\n    clearTimeout(properties.timeoutId);\n    if (val > 0 && properties.timeoutFn) {\n      properties.timeoutId = setTimeout(properties.timeoutFn, Math.max(0, val - (new Date().getTime() - properties.timeoutStart)));\n    } else {\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n    }\n  }\n  get withCredentials() {\n    return this.flag.withCredentials;\n  }\n  set withCredentials(val) {\n    const {\n      flag,\n      properties\n    } = this;\n    if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED)) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    flag.withCredentials = val;\n  }\n  abort() {\n    const {\n      properties\n    } = this;\n    // Terminate the request\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    const {\n      client\n    } = properties;\n    if (client) {\n      client.abort();\n      properties.client = null;\n    }\n    if (properties.abortError) {\n      // Special case that ideally shouldn't be going through the public API at all.\n      // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n      this.readyState = READY_STATES.DONE;\n      properties.send = false;\n      xhrUtils.setResponseToNetworkError(this);\n      return;\n    }\n    if (this.readyState === READY_STATES.OPENED && properties.send || this.readyState === READY_STATES.HEADERS_RECEIVED || this.readyState === READY_STATES.LOADING) {\n      xhrUtils.requestErrorSteps(this, \"abort\");\n    }\n    if (this.readyState === READY_STATES.DONE) {\n      this.readyState = READY_STATES.UNSENT;\n      xhrUtils.setResponseToNetworkError(this);\n    }\n  }\n  getAllResponseHeaders() {\n    const {\n      properties,\n      readyState\n    } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return \"\";\n    }\n    return Object.keys(properties.responseHeaders).filter(key => properties.filteredResponseHeaders.indexOf(key) === -1).map(key => [key.toLowerCase(), properties.responseHeaders[key]].join(\": \")).join(\"\\r\\n\");\n  }\n  getResponseHeader(header) {\n    const {\n      properties,\n      readyState\n    } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return null;\n    }\n    const lcHeader = header.toLowerCase();\n    if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n      return null;\n    }\n    return getResponseHeader(this, lcHeader);\n  }\n  open(method, uri, asynchronous, user, password) {\n    const {\n      flag,\n      properties,\n      _ownerDocument\n    } = this;\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (!tokenRegexp.test(method)) {\n      throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n    }\n    const upperCaseMethod = method.toUpperCase();\n    if (forbiddenRequestMethods.has(upperCaseMethod)) {\n      throw DOMException.create(this._globalObject, [\"The operation is insecure.\", \"SecurityError\"]);\n    }\n    const {\n      client\n    } = properties;\n    if (client && typeof client.abort === \"function\") {\n      client.abort();\n    }\n    if (allowedRequestMethods.has(upperCaseMethod)) {\n      method = upperCaseMethod;\n    }\n    if (typeof asynchronous !== \"undefined\") {\n      flag.synchronous = !asynchronous;\n    } else {\n      flag.synchronous = false;\n    }\n    if (flag.responseType && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n    if (flag.synchronous && flag.timeout) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n    flag.method = method;\n    let urlObj;\n    try {\n      urlObj = new URL(uri, documentBaseURLSerialized(_ownerDocument));\n    } catch (e) {\n      throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n    }\n    if (user || password && !urlObj.username) {\n      flag.auth = {\n        user,\n        pass: password\n      };\n      urlObj.username = \"\";\n      urlObj.password = \"\";\n    }\n    flag.uri = urlObj.href;\n    flag.requestHeaders = {};\n    flag.preflight = false;\n    properties.send = false;\n    properties.uploadListener = false;\n    properties.abortError = false;\n    this.responseURL = \"\";\n    readyStateChange(this, READY_STATES.OPENED);\n  }\n  overrideMimeType(mime) {\n    const {\n      readyState\n    } = this;\n    if (readyState === READY_STATES.LOADING || readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    this.flag.overrideMIMEType = \"application/octet-stream\";\n\n    // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n    const parsed = MIMEType.parse(mime);\n    if (parsed) {\n      this.flag.overrideMIMEType = parsed.essence;\n      const charset = parsed.parameters.get(\"charset\");\n      if (charset) {\n        this.flag.overrideCharset = whatwgEncoding.labelToName(charset);\n      }\n    }\n  }\n\n  // TODO: Add support for URLSearchParams and ReadableStream\n  send(body) {\n    const {\n      flag,\n      properties,\n      upload,\n      _ownerDocument\n    } = this;\n    // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    properties.beforeSend = true;\n    try {\n      if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n        body = null;\n      }\n      if (body !== null) {\n        let encoding = null;\n        let mimeType = null;\n        if (Document.isImpl(body)) {\n          encoding = \"UTF-8\";\n          mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n          flag.body = fragmentSerialization(body, {\n            requireWellFormed: false\n          });\n        } else {\n          if (typeof body === \"string\") {\n            encoding = \"UTF-8\";\n          }\n          const {\n            buffer,\n            formData,\n            contentType\n          } = extractBody(body);\n          mimeType = contentType;\n          flag.body = buffer || formData;\n          flag.formData = Boolean(formData);\n        }\n        const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n        if (mimeType !== null && existingContentType === null) {\n          flag.requestHeaders[\"Content-Type\"] = mimeType;\n        } else if (existingContentType !== null && encoding !== null) {\n          // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n          // the spec will be, in the meantime.\n          const parsed = MIMEType.parse(existingContentType);\n          if (parsed) {\n            const charset = parsed.parameters.get(\"charset\");\n            if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n              parsed.parameters.set(\"charset\", encoding);\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      }\n    } finally {\n      if (properties.beforeSend) {\n        properties.beforeSend = false;\n      } else {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n    }\n    if (Object.keys(upload._eventListeners).length > 0) {\n      properties.uploadListener = true;\n    }\n\n    // request doesn't like zero-length bodies\n    if (flag.body && flag.body.byteLength === 0) {\n      flag.body = null;\n    }\n    if (flag.synchronous) {\n      const flagStr = JSON.stringify(flag, function (k, v) {\n        if (this === flag && k === \"requestManager\") {\n          return null;\n        }\n        if (this === flag && k === \"pool\" && v) {\n          return {\n            maxSockets: v.maxSockets\n          };\n        }\n        return v;\n      });\n      const res = spawnSync(process.execPath, [syncWorkerFile], {\n        input: flagStr,\n        maxBuffer: Infinity\n      });\n      if (res.status !== 0) {\n        throw new Error(res.stderr.toString());\n      }\n      if (res.error) {\n        if (typeof res.error === \"string\") {\n          res.error = new Error(res.error);\n        }\n        throw res.error;\n      }\n      const response = JSON.parse(res.stdout.toString());\n      const resProp = response.properties;\n      if (resProp.responseBuffer && resProp.responseBuffer.data) {\n        resProp.responseBuffer = Buffer.from(resProp.responseBuffer.data);\n      }\n      if (resProp.cookieJar) {\n        resProp.cookieJar = tough.CookieJar.deserializeSync(resProp.cookieJar, _ownerDocument._cookieJar.store);\n      }\n      this.readyState = READY_STATES.LOADING;\n      this.status = response.status;\n      this.statusText = response.statusText;\n      this.responseURL = response.responseURL;\n      Object.assign(this.properties, response.properties);\n      if (resProp.error) {\n        xhrUtils.dispatchError(this);\n        throw DOMException.create(this._globalObject, [resProp.error, \"NetworkError\"]);\n      } else {\n        const {\n          responseBuffer\n        } = properties;\n        const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n        const bufferLength = parseInt(contentLength) || responseBuffer.length;\n        const progressObj = {\n          lengthComputable: false\n        };\n        if (bufferLength !== 0) {\n          progressObj.total = bufferLength;\n          progressObj.loaded = bufferLength;\n          progressObj.lengthComputable = true;\n        }\n        fireAnEvent(\"progress\", this, ProgressEvent, progressObj);\n        readyStateChange(this, READY_STATES.DONE);\n        fireAnEvent(\"load\", this, ProgressEvent, progressObj);\n        fireAnEvent(\"loadend\", this, ProgressEvent, progressObj);\n      }\n    } else {\n      properties.send = true;\n      fireAnEvent(\"loadstart\", this, ProgressEvent);\n      const client = xhrUtils.createClient(this);\n      properties.client = client;\n      // For new client, reset totalReceivedChunkSize and bufferStepSize\n      properties.totalReceivedChunkSize = 0;\n      properties.bufferStepSize = 1 * 1024 * 1024;\n      properties.origin = flag.origin;\n      client.on(\"error\", err => {\n        client.removeAllListeners();\n        properties.error = err;\n        xhrUtils.dispatchError(this);\n      });\n      client.on(\"response\", (res, url) => receiveResponse(this, res, url));\n      client.on(\"redirect\", (response, requestHeaders, currentURL) => {\n        const destUrlObj = new URL(requestHeaders.Referer);\n        const urlObj = new URL(currentURL);\n        if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n          properties.origin = \"null\";\n        }\n        requestHeaders.Origin = properties.origin;\n        if (flag.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n          if (!xhrUtils.validCORSHeaders(this, response, flag, properties, flag.origin)) {\n            return;\n          }\n          if (urlObj.username || urlObj.password) {\n            properties.error = \"Userinfo forbidden in cors redirect\";\n            xhrUtils.dispatchError(this);\n          }\n        }\n      });\n      if (body !== null && body !== \"\") {\n        properties.uploadComplete = false;\n        setDispatchProgressEvents(this);\n      } else {\n        properties.uploadComplete = true;\n      }\n      if (this.timeout > 0) {\n        properties.timeoutStart = new Date().getTime();\n        properties.timeoutFn = () => {\n          client.abort();\n          if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED && !properties.send || this.readyState === READY_STATES.DONE)) {\n            properties.send = false;\n            let stateChanged = false;\n            if (!properties.uploadComplete) {\n              fireAnEvent(\"progress\", upload, ProgressEvent);\n              readyStateChange(this, READY_STATES.DONE);\n              fireAnEvent(\"timeout\", upload, ProgressEvent);\n              fireAnEvent(\"loadend\", upload, ProgressEvent);\n              stateChanged = true;\n            }\n            fireAnEvent(\"progress\", this, ProgressEvent);\n            if (!stateChanged) {\n              readyStateChange(this, READY_STATES.DONE);\n            }\n            fireAnEvent(\"timeout\", this, ProgressEvent);\n            fireAnEvent(\"loadend\", this, ProgressEvent);\n          }\n          this.readyState = READY_STATES.UNSENT;\n        };\n        properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n      }\n    }\n  }\n  setRequestHeader(header, value) {\n    const {\n      flag,\n      properties\n    } = this;\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    value = normalizeHeaderValue(value);\n    if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n      throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n    }\n    const lcHeader = header.toLowerCase();\n    if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n      return;\n    }\n    const keys = Object.keys(flag.requestHeaders);\n    let n = keys.length;\n    while (n--) {\n      const key = keys[n];\n      if (key.toLowerCase() === lcHeader) {\n        flag.requestHeaders[key] += \", \" + value;\n        return;\n      }\n    }\n    flag.requestHeaders[header] = value;\n  }\n}\nsetupForSimpleEventAccessors(XMLHttpRequestImpl.prototype, [\"readystatechange\"]);\nfunction readyStateChange(xhr, readyState) {\n  if (xhr.readyState === readyState) {\n    return;\n  }\n  xhr.readyState = readyState;\n  fireAnEvent(\"readystatechange\", xhr);\n}\nfunction receiveResponse(xhr, response, currentURL) {\n  const {\n    flag,\n    properties\n  } = xhr;\n  const {\n    rawHeaders,\n    statusCode\n  } = response;\n  let byteOffset = 0;\n  const headers = {};\n  const filteredResponseHeaders = [];\n  const headerMap = {};\n  const n = Number(rawHeaders.length);\n  for (let i = 0; i < n; i += 2) {\n    const k = rawHeaders[i];\n    const kl = k.toLowerCase();\n    const v = rawHeaders[i + 1];\n    if (uniqueResponseHeaders.has(kl)) {\n      if (headerMap[kl] !== undefined) {\n        delete headers[headerMap[kl]];\n      }\n      headers[k] = v;\n    } else if (headerMap[kl] !== undefined) {\n      headers[headerMap[kl]] += \", \" + v;\n    } else {\n      headers[k] = v;\n    }\n    headerMap[kl] = k;\n  }\n  const destUrlObj = new URL(currentURL);\n  if (properties.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n    if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n      return;\n    }\n    const acehStr = response.headers[\"access-control-expose-headers\"];\n    const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n      if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n  }\n  for (const header in headers) {\n    const lcHeader = header.toLowerCase();\n    if (forbiddenResponseHeaders.has(lcHeader)) {\n      filteredResponseHeaders.push(header);\n    }\n  }\n  xhr.responseURL = destUrlObj.href;\n  xhr.status = statusCode;\n  xhr.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n  properties.responseHeaders = headers;\n  properties.filteredResponseHeaders = filteredResponseHeaders;\n  const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n  const bufferLength = parseInt(contentLength) || 0;\n  const progressObj = {\n    lengthComputable: false\n  };\n  let lastProgressReported;\n  if (bufferLength !== 0) {\n    progressObj.total = bufferLength;\n    progressObj.loaded = 0;\n    progressObj.lengthComputable = true;\n  }\n  // pre-allocate buffer.\n  properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n  properties.responseCache = null;\n  properties.responseTextCache = null;\n  properties.responseXMLCache = null;\n  readyStateChange(xhr, READY_STATES.HEADERS_RECEIVED);\n  if (!properties.client) {\n    // The request was aborted in reaction to the readystatechange event.\n    return;\n  }\n\n  // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n  // Content-Length).\n  response.on(\"data\", chunk => {\n    byteOffset += chunk.length;\n    progressObj.loaded = byteOffset;\n  });\n  properties.client.on(\"data\", chunk => {\n    properties.totalReceivedChunkSize += chunk.length;\n    if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n      properties.bufferStepSize *= 2;\n      while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n      }\n      const tmpBuf = Buffer.alloc(properties.bufferStepSize);\n      properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n      properties.responseBuffer = tmpBuf;\n    }\n    chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n    if (xhr.readyState === READY_STATES.HEADERS_RECEIVED) {\n      xhr.readyState = READY_STATES.LOADING;\n    }\n    fireAnEvent(\"readystatechange\", xhr);\n    if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n      if (lastProgressReported !== progressObj.loaded) {\n        // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n        // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n        lastProgressReported = progressObj.loaded;\n        fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n      }\n    }\n  });\n  properties.client.on(\"end\", () => {\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    properties.client = null;\n    if (lastProgressReported !== progressObj.loaded) {\n      // https://github.com/whatwg/xhr/issues/318\n      fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n    }\n    readyStateChange(xhr, READY_STATES.DONE);\n    fireAnEvent(\"load\", xhr, ProgressEvent, progressObj);\n    fireAnEvent(\"loadend\", xhr, ProgressEvent, progressObj);\n  });\n}\nfunction setDispatchProgressEvents(xhr) {\n  const {\n    properties,\n    upload\n  } = xhr;\n  const {\n    client\n  } = properties;\n  let total = 0;\n  let lengthComputable = false;\n  const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n  if (length) {\n    total = length;\n    lengthComputable = true;\n  }\n  const initProgress = {\n    lengthComputable,\n    total,\n    loaded: 0\n  };\n  if (properties.uploadListener) {\n    fireAnEvent(\"loadstart\", upload, ProgressEvent, initProgress);\n  }\n  client.on(\"request\", req => {\n    req.on(\"response\", () => {\n      properties.uploadComplete = true;\n      if (!properties.uploadListener) {\n        return;\n      }\n      const progress = {\n        lengthComputable,\n        total,\n        loaded: total\n      };\n      fireAnEvent(\"progress\", upload, ProgressEvent, progress);\n      fireAnEvent(\"load\", upload, ProgressEvent, progress);\n      fireAnEvent(\"loadend\", upload, ProgressEvent, progress);\n    });\n  });\n}\nfunction finalMIMEType(xhr) {\n  const {\n    flag\n  } = xhr;\n  return flag.overrideMIMEType || getResponseHeader(xhr, \"content-type\");\n}\nfunction finalCharset(xhr) {\n  const {\n    flag\n  } = xhr;\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n  const parsedContentType = MIMEType.parse(getResponseHeader(xhr, \"content-type\"));\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n  return null;\n}\nfunction getResponseHeader(xhr, lcHeader) {\n  const {\n    properties\n  } = xhr;\n  const keys = Object.keys(properties.responseHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n  return null;\n}\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (isArrayBuffer(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    const formData = [];\n    for (const entry of bodyInit._entries) {\n      let val;\n      if (Blob.isImpl(entry.value)) {\n        const blob = entry.value;\n        val = {\n          name: entry.name,\n          value: blob._buffer,\n          options: {\n            filename: blob.name,\n            contentType: blob.type,\n            knownLength: blob.size\n          }\n        };\n      } else {\n        val = entry;\n      }\n      formData.push(val);\n    }\n    return {\n      formData\n    };\n  }\n\n  // Must be a string\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}\nexports.implementation = XMLHttpRequestImpl;","map":{"version":3,"names":["HTTP_STATUS_CODES","require","STATUS_CODES","spawnSync","URL","whatwgEncoding","tough","MIMEType","xhrUtils","DOMException","documentBaseURLSerialized","asciiCaseInsensitiveMatch","idlUtils","Document","Blob","FormData","XMLHttpRequestEventTargetImpl","implementation","XMLHttpRequestUpload","ProgressEvent","isArrayBuffer","parseIntoDocument","fragmentSerialization","setupForSimpleEventAccessors","parseJSONFromBytes","fireAnEvent","copyToArrayBufferInNewRealm","READY_STATES","syncWorkerFile","resolve","tokenRegexp","fieldValueRegexp","forbiddenRequestHeaders","Set","forbiddenResponseHeaders","uniqueResponseHeaders","corsSafeResponseHeaders","allowedRequestMethods","forbiddenRequestMethods","XMLHttpRequestImpl","constructor","window","_ownerDocument","upload","createImpl","readyState","UNSENT","responseURL","status","statusText","flag","synchronous","withCredentials","mimeType","auth","method","undefined","responseType","requestHeaders","referrer","uri","timeout","body","formData","preflight","requestManager","_requestManager","strictSSL","_resourceLoader","_strictSSL","proxy","_proxy","cookieJar","_cookieJar","encoding","_encoding","origin","_origin","userAgent","navigator","properties","beforeSend","send","client","timeoutStart","timeoutId","timeoutFn","responseBuffer","responseCache","responseTextCache","responseXMLCache","responseHeaders","filteredResponseHeaders","error","uploadComplete","uploadListener","abortError","bufferStepSize","totalReceivedChunkSize","LOADING","DONE","create","_globalObject","OPENED","response","tryWrapperForImpl","res","slice","responseText","contentType","finalMIMEType","Uint8Array","type","responseXML","e","fallbackEncoding","finalCharset","getBOMEncoding","decode","isHTML","isXML","parsed","parse","resText","options","url","lastModified","Date","getResponseHeader","parsingMode","setCookieSync","getCookieStringSync","parseOptions","_parseOptions","close","val","clearTimeout","setTimeout","Math","max","getTime","abort","setResponseToNetworkError","HEADERS_RECEIVED","requestErrorSteps","getAllResponseHeaders","Object","keys","filter","key","indexOf","map","toLowerCase","join","header","lcHeader","find","filtered","open","asynchronous","user","password","test","upperCaseMethod","toUpperCase","has","urlObj","username","pass","href","readyStateChange","overrideMimeType","mime","overrideMIMEType","essence","charset","parameters","get","overrideCharset","labelToName","isImpl","_parsingMode","requireWellFormed","buffer","extractBody","Boolean","existingContentType","getRequestHeader","set","updateRequestHeader","toString","_eventListeners","length","byteLength","flagStr","JSON","stringify","k","v","maxSockets","process","execPath","input","maxBuffer","Infinity","Error","stderr","stdout","resProp","data","Buffer","from","CookieJar","deserializeSync","store","assign","dispatchError","contentLength","bufferLength","parseInt","progressObj","lengthComputable","total","loaded","createClient","on","err","removeAllListeners","receiveResponse","currentURL","destUrlObj","Referer","Origin","protocol","validCORSHeaders","setDispatchProgressEvents","stateChanged","setRequestHeader","value","normalizeHeaderValue","startsWith","n","prototype","xhr","rawHeaders","statusCode","byteOffset","headers","headerMap","Number","i","kl","acehStr","aceh","trim","split","headerListSeparatorRegexp","push","statusMessage","lastProgressReported","alloc","chunk","tmpBuf","copy","initProgress","req","progress","parsedContentType","replace","bodyInit","_buffer","ArrayBuffer","isView","entry","_entries","blob","name","filename","knownLength","size","exports"],"sources":["/home/dove/Documents/tchek/AnnotationOSD/node_modules/jsdom/lib/jsdom/living/xhr/XMLHttpRequest-impl.js"],"sourcesContent":["\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\nconst { spawnSync } = require(\"child_process\");\nconst { URL } = require(\"whatwg-url\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst tough = require(\"tough-cookie\");\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst xhrUtils = require(\"./xhr-utils\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { asciiCaseInsensitiveMatch } = require(\"../helpers/strings\");\nconst idlUtils = require(\"../generated/utils\");\nconst Document = require(\"../generated/Document\");\nconst Blob = require(\"../generated/Blob\");\nconst FormData = require(\"../generated/FormData\");\nconst XMLHttpRequestEventTargetImpl = require(\"./XMLHttpRequestEventTarget-impl\").implementation;\nconst XMLHttpRequestUpload = require(\"../generated/XMLHttpRequestUpload\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst { isArrayBuffer } = require(\"../generated/utils\");\nconst { parseIntoDocument } = require(\"../../browser/parser\");\nconst { fragmentSerialization } = require(\"../domparsing/serialization\");\nconst { setupForSimpleEventAccessors } = require(\"../helpers/create-event-accessor\");\nconst { parseJSONFromBytes } = require(\"../helpers/json\");\nconst { fireAnEvent } = require(\"../helpers/events\");\nconst { copyToArrayBufferInNewRealm } = require(\"../helpers/binary-data\");\n\nconst { READY_STATES } = xhrUtils;\n\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\n\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\n\nconst forbiddenRequestHeaders = new Set([\n  \"accept-charset\",\n  \"accept-encoding\",\n  \"access-control-request-headers\",\n  \"access-control-request-method\",\n  \"connection\",\n  \"content-length\",\n  \"cookie\",\n  \"cookie2\",\n  \"date\",\n  \"dnt\",\n  \"expect\",\n  \"host\",\n  \"keep-alive\",\n  \"origin\",\n  \"referer\",\n  \"te\",\n  \"trailer\",\n  \"transfer-encoding\",\n  \"upgrade\",\n  \"via\"\n]);\nconst forbiddenResponseHeaders = new Set([\n  \"set-cookie\",\n  \"set-cookie2\"\n]);\nconst uniqueResponseHeaders = new Set([\n  \"content-type\",\n  \"content-length\",\n  \"user-agent\",\n  \"referer\",\n  \"host\",\n  \"authorization\",\n  \"proxy-authorization\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"from\",\n  \"location\",\n  \"max-forwards\"\n]);\nconst corsSafeResponseHeaders = new Set([\n  \"cache-control\",\n  \"content-language\",\n  \"content-length\",\n  \"content-type\",\n  \"expires\",\n  \"last-modified\",\n  \"pragma\"\n]);\n\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nclass XMLHttpRequestImpl extends XMLHttpRequestEventTargetImpl {\n  constructor(window) {\n    super(window);\n\n    // Avoid running `_ownerDocument` getter multiple times in the constructor:\n    const { _ownerDocument } = this;\n\n    this.upload = XMLHttpRequestUpload.createImpl(window);\n\n    this.readyState = READY_STATES.UNSENT;\n    this.responseURL = \"\";\n    this.status = 0;\n    this.statusText = \"\";\n\n    this.flag = {\n      synchronous: false,\n      withCredentials: false,\n      mimeType: null,\n      auth: null,\n      method: undefined,\n      responseType: \"\",\n      requestHeaders: {},\n      referrer: _ownerDocument.URL,\n      uri: \"\",\n      timeout: 0,\n      body: undefined,\n      formData: false,\n      preflight: false,\n      requestManager: _ownerDocument._requestManager,\n      strictSSL: window._resourceLoader._strictSSL,\n      proxy: window._resourceLoader._proxy,\n      cookieJar: _ownerDocument._cookieJar,\n      encoding: _ownerDocument._encoding,\n      origin: window._origin,\n      userAgent: window.navigator.userAgent\n    };\n\n    this.properties = {\n      beforeSend: false,\n      send: false,\n      client: null,\n\n      timeoutStart: 0,\n      timeoutId: 0,\n      timeoutFn: null,\n\n      responseBuffer: null,\n      responseCache: null,\n      responseTextCache: null,\n      responseXMLCache: null,\n\n      responseHeaders: {},\n      filteredResponseHeaders: [],\n\n      error: \"\",\n      uploadComplete: false,\n      uploadListener: false,\n\n      // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n      // In that case the termination reason is \"fatal\", not \"end-user abort\".\n      abortError: false,\n\n      cookieJar: _ownerDocument._cookieJar,\n      bufferStepSize: 1 * 1024 * 1024, // pre-allocate buffer increase step size. init value is 1MB\n      totalReceivedChunkSize: 0\n    };\n  }\n\n  get responseType() {\n    return this.flag.responseType;\n  }\n  set responseType(responseType) {\n    const { flag } = this;\n    if (this.readyState === READY_STATES.LOADING || this.readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState === READY_STATES.OPENED && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.responseType = responseType;\n  }\n\n  get response() {\n    const { properties } = this;\n    if (properties.responseCache) {\n      // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n      return idlUtils.tryWrapperForImpl(properties.responseCache);\n    }\n    let res;\n\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    switch (this.responseType) {\n      case \"\":\n      case \"text\": {\n        res = this.responseText;\n        break;\n      }\n      case \"arraybuffer\": {\n        if (!responseBuffer) {\n          return null;\n        }\n        res = copyToArrayBufferInNewRealm(responseBuffer, this._globalObject);\n        break;\n      }\n      case \"blob\": {\n        if (!responseBuffer) {\n          return null;\n        }\n        const contentType = finalMIMEType(this);\n        res = Blob.createImpl(this._globalObject, [\n          [new Uint8Array(responseBuffer)],\n          { type: contentType || \"\" }\n        ]);\n        break;\n      }\n      case \"document\": {\n        res = this.responseXML;\n        break;\n      }\n      case \"json\": {\n        if (this.readyState !== READY_STATES.DONE || !responseBuffer) {\n          res = null;\n        }\n\n        try {\n          res = parseJSONFromBytes(responseBuffer);\n        } catch (e) {\n          res = null;\n        }\n        break;\n      }\n    }\n    properties.responseCache = res;\n    // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n    return idlUtils.tryWrapperForImpl(res);\n  }\n  get responseText() {\n    const { properties } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"text\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.LOADING && this.readyState !== READY_STATES.DONE) {\n      return \"\";\n    }\n    if (properties.responseTextCache) {\n      return properties.responseTextCache;\n    }\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    if (!responseBuffer) {\n      return \"\";\n    }\n\n    const fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n\n    properties.responseTextCache = res;\n    return res;\n  }\n  get responseXML() {\n    const { flag, properties } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"document\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.DONE) {\n      return null;\n    }\n    if (properties.responseXMLCache) {\n      return properties.responseXMLCache;\n    }\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    if (!responseBuffer) {\n      return null;\n    }\n\n    const contentType = finalMIMEType(this);\n    let isHTML = false;\n    let isXML = false;\n    const parsed = MIMEType.parse(contentType);\n    if (parsed) {\n      isHTML = parsed.isHTML();\n      isXML = parsed.isXML();\n      if (!isXML && !isHTML) {\n        return null;\n      }\n    }\n\n    if (this.responseType === \"\" && isHTML) {\n      return null;\n    }\n\n    const encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n    if (!resText) {\n      return null;\n    }\n    const res = Document.createImpl(this._globalObject, [], {\n      options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: { setCookieSync: () => undefined, getCookieStringSync: () => \"\" },\n        encoding,\n        parseOptions: this._ownerDocument._parseOptions\n      }\n    });\n    try {\n      parseIntoDocument(resText, res);\n    } catch (e) {\n      properties.responseXMLCache = null;\n      return null;\n    }\n    res.close();\n    properties.responseXMLCache = res;\n    return res;\n  }\n\n  get timeout() {\n    return this.flag.timeout;\n  }\n  set timeout(val) {\n    const { flag, properties } = this;\n    if (flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.timeout = val;\n    clearTimeout(properties.timeoutId);\n    if (val > 0 && properties.timeoutFn) {\n      properties.timeoutId = setTimeout(\n        properties.timeoutFn,\n        Math.max(0, val - ((new Date()).getTime() - properties.timeoutStart))\n      );\n    } else {\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n    }\n  }\n\n  get withCredentials() {\n    return this.flag.withCredentials;\n  }\n  set withCredentials(val) {\n    const { flag, properties } = this;\n    if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED)) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    flag.withCredentials = val;\n  }\n\n  abort() {\n    const { properties } = this;\n    // Terminate the request\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n\n    const { client } = properties;\n    if (client) {\n      client.abort();\n      properties.client = null;\n    }\n\n    if (properties.abortError) {\n      // Special case that ideally shouldn't be going through the public API at all.\n      // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n      this.readyState = READY_STATES.DONE;\n      properties.send = false;\n      xhrUtils.setResponseToNetworkError(this);\n      return;\n    }\n\n    if ((this.readyState === READY_STATES.OPENED && properties.send) ||\n        this.readyState === READY_STATES.HEADERS_RECEIVED ||\n        this.readyState === READY_STATES.LOADING) {\n      xhrUtils.requestErrorSteps(this, \"abort\");\n    }\n\n    if (this.readyState === READY_STATES.DONE) {\n      this.readyState = READY_STATES.UNSENT;\n\n      xhrUtils.setResponseToNetworkError(this);\n    }\n  }\n  getAllResponseHeaders() {\n    const { properties, readyState } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return \"\";\n    }\n    return Object.keys(properties.responseHeaders)\n      .filter(key => properties.filteredResponseHeaders.indexOf(key) === -1)\n      .map(key => [key.toLowerCase(), properties.responseHeaders[key]].join(\": \"))\n      .join(\"\\r\\n\");\n  }\n\n  getResponseHeader(header) {\n    const { properties, readyState } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return null;\n    }\n    const lcHeader = header.toLowerCase();\n    if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n      return null;\n    }\n    return getResponseHeader(this, lcHeader);\n  }\n\n  open(method, uri, asynchronous, user, password) {\n    const { flag, properties, _ownerDocument } = this;\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (!tokenRegexp.test(method)) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n    const upperCaseMethod = method.toUpperCase();\n    if (forbiddenRequestMethods.has(upperCaseMethod)) {\n      throw DOMException.create(this._globalObject, [\"The operation is insecure.\", \"SecurityError\"]);\n    }\n\n    const { client } = properties;\n    if (client && typeof client.abort === \"function\") {\n      client.abort();\n    }\n\n    if (allowedRequestMethods.has(upperCaseMethod)) {\n      method = upperCaseMethod;\n    }\n    if (typeof asynchronous !== \"undefined\") {\n      flag.synchronous = !asynchronous;\n    } else {\n      flag.synchronous = false;\n    }\n    if (flag.responseType && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    if (flag.synchronous && flag.timeout) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.method = method;\n\n    let urlObj;\n    try {\n      urlObj = new URL(uri, documentBaseURLSerialized(_ownerDocument));\n    } catch (e) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    if (user || (password && !urlObj.username)) {\n      flag.auth = {\n        user,\n        pass: password\n      };\n      urlObj.username = \"\";\n      urlObj.password = \"\";\n    }\n\n    flag.uri = urlObj.href;\n    flag.requestHeaders = {};\n    flag.preflight = false;\n\n    properties.send = false;\n    properties.uploadListener = false;\n    properties.abortError = false;\n    this.responseURL = \"\";\n    readyStateChange(this, READY_STATES.OPENED);\n  }\n\n  overrideMimeType(mime) {\n    const { readyState } = this;\n    if (readyState === READY_STATES.LOADING || readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    this.flag.overrideMIMEType = \"application/octet-stream\";\n\n    // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n    const parsed = MIMEType.parse(mime);\n    if (parsed) {\n      this.flag.overrideMIMEType = parsed.essence;\n\n      const charset = parsed.parameters.get(\"charset\");\n      if (charset) {\n        this.flag.overrideCharset = whatwgEncoding.labelToName(charset);\n      }\n    }\n  }\n\n  // TODO: Add support for URLSearchParams and ReadableStream\n  send(body) {\n    const { flag, properties, upload, _ownerDocument } = this;\n    // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    properties.beforeSend = true;\n\n    try {\n      if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n        body = null;\n      }\n\n      if (body !== null) {\n        let encoding = null;\n        let mimeType = null;\n\n        if (Document.isImpl(body)) {\n          encoding = \"UTF-8\";\n          mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n          flag.body = fragmentSerialization(body, { requireWellFormed: false });\n        } else {\n          if (typeof body === \"string\") {\n            encoding = \"UTF-8\";\n          }\n          const { buffer, formData, contentType } = extractBody(body);\n          mimeType = contentType;\n          flag.body = buffer || formData;\n          flag.formData = Boolean(formData);\n        }\n\n        const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n        if (mimeType !== null && existingContentType === null) {\n          flag.requestHeaders[\"Content-Type\"] = mimeType;\n        } else if (existingContentType !== null && encoding !== null) {\n          // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n          // the spec will be, in the meantime.\n          const parsed = MIMEType.parse(existingContentType);\n          if (parsed) {\n            const charset = parsed.parameters.get(\"charset\");\n            if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n              parsed.parameters.set(\"charset\", encoding);\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      }\n    } finally {\n      if (properties.beforeSend) {\n        properties.beforeSend = false;\n      } else {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n    }\n\n    if (Object.keys(upload._eventListeners).length > 0) {\n      properties.uploadListener = true;\n    }\n\n    // request doesn't like zero-length bodies\n    if (flag.body && flag.body.byteLength === 0) {\n      flag.body = null;\n    }\n\n    if (flag.synchronous) {\n      const flagStr = JSON.stringify(flag, function (k, v) {\n        if (this === flag && k === \"requestManager\") {\n          return null;\n        }\n        if (this === flag && k === \"pool\" && v) {\n          return { maxSockets: v.maxSockets };\n        }\n        return v;\n      });\n      const res = spawnSync(\n        process.execPath,\n        [syncWorkerFile],\n        { input: flagStr, maxBuffer: Infinity }\n      );\n      if (res.status !== 0) {\n        throw new Error(res.stderr.toString());\n      }\n      if (res.error) {\n        if (typeof res.error === \"string\") {\n          res.error = new Error(res.error);\n        }\n        throw res.error;\n      }\n\n      const response = JSON.parse(res.stdout.toString());\n      const resProp = response.properties;\n      if (resProp.responseBuffer && resProp.responseBuffer.data) {\n        resProp.responseBuffer = Buffer.from(resProp.responseBuffer.data);\n      }\n      if (resProp.cookieJar) {\n        resProp.cookieJar = tough.CookieJar.deserializeSync(\n          resProp.cookieJar,\n          _ownerDocument._cookieJar.store\n        );\n      }\n\n      this.readyState = READY_STATES.LOADING;\n      this.status = response.status;\n      this.statusText = response.statusText;\n      this.responseURL = response.responseURL;\n      Object.assign(this.properties, response.properties);\n\n      if (resProp.error) {\n        xhrUtils.dispatchError(this);\n        throw DOMException.create(this._globalObject, [resProp.error, \"NetworkError\"]);\n      } else {\n        const { responseBuffer } = properties;\n        const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n        const bufferLength = parseInt(contentLength) || responseBuffer.length;\n        const progressObj = { lengthComputable: false };\n        if (bufferLength !== 0) {\n          progressObj.total = bufferLength;\n          progressObj.loaded = bufferLength;\n          progressObj.lengthComputable = true;\n        }\n        fireAnEvent(\"progress\", this, ProgressEvent, progressObj);\n        readyStateChange(this, READY_STATES.DONE);\n        fireAnEvent(\"load\", this, ProgressEvent, progressObj);\n        fireAnEvent(\"loadend\", this, ProgressEvent, progressObj);\n      }\n    } else {\n      properties.send = true;\n\n      fireAnEvent(\"loadstart\", this, ProgressEvent);\n\n      const client = xhrUtils.createClient(this);\n\n      properties.client = client;\n      // For new client, reset totalReceivedChunkSize and bufferStepSize\n      properties.totalReceivedChunkSize = 0;\n      properties.bufferStepSize = 1 * 1024 * 1024;\n\n      properties.origin = flag.origin;\n\n      client.on(\"error\", err => {\n        client.removeAllListeners();\n        properties.error = err;\n        xhrUtils.dispatchError(this);\n      });\n\n      client.on(\"response\", (res, url) => receiveResponse(this, res, url));\n\n      client.on(\"redirect\", (response, requestHeaders, currentURL) => {\n        const destUrlObj = new URL(requestHeaders.Referer);\n        const urlObj = new URL(currentURL);\n\n        if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n          properties.origin = \"null\";\n        }\n\n        requestHeaders.Origin = properties.origin;\n\n        if (flag.origin !== destUrlObj.origin &&\n            destUrlObj.protocol !== \"data:\") {\n          if (!xhrUtils.validCORSHeaders(this, response, flag, properties, flag.origin)) {\n            return;\n          }\n          if (urlObj.username || urlObj.password) {\n            properties.error = \"Userinfo forbidden in cors redirect\";\n            xhrUtils.dispatchError(this);\n          }\n        }\n      });\n      if (body !== null && body !== \"\") {\n        properties.uploadComplete = false;\n        setDispatchProgressEvents(this);\n      } else {\n        properties.uploadComplete = true;\n      }\n      if (this.timeout > 0) {\n        properties.timeoutStart = (new Date()).getTime();\n        properties.timeoutFn = () => {\n          client.abort();\n          if (!(this.readyState === READY_STATES.UNSENT ||\n              (this.readyState === READY_STATES.OPENED && !properties.send) ||\n              this.readyState === READY_STATES.DONE)) {\n            properties.send = false;\n            let stateChanged = false;\n            if (!properties.uploadComplete) {\n              fireAnEvent(\"progress\", upload, ProgressEvent);\n              readyStateChange(this, READY_STATES.DONE);\n              fireAnEvent(\"timeout\", upload, ProgressEvent);\n              fireAnEvent(\"loadend\", upload, ProgressEvent);\n              stateChanged = true;\n            }\n            fireAnEvent(\"progress\", this, ProgressEvent);\n            if (!stateChanged) {\n              readyStateChange(this, READY_STATES.DONE);\n            }\n            fireAnEvent(\"timeout\", this, ProgressEvent);\n            fireAnEvent(\"loadend\", this, ProgressEvent);\n          }\n          this.readyState = READY_STATES.UNSENT;\n        };\n        properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n      }\n    }\n  }\n\n  setRequestHeader(header, value) {\n    const { flag, properties } = this;\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    value = normalizeHeaderValue(value);\n\n    if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    const lcHeader = header.toLowerCase();\n\n    if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n      return;\n    }\n\n    const keys = Object.keys(flag.requestHeaders);\n    let n = keys.length;\n    while (n--) {\n      const key = keys[n];\n      if (key.toLowerCase() === lcHeader) {\n        flag.requestHeaders[key] += \", \" + value;\n        return;\n      }\n    }\n    flag.requestHeaders[header] = value;\n  }\n}\n\nsetupForSimpleEventAccessors(XMLHttpRequestImpl.prototype, [\"readystatechange\"]);\n\nfunction readyStateChange(xhr, readyState) {\n  if (xhr.readyState === readyState) {\n    return;\n  }\n\n  xhr.readyState = readyState;\n\n  fireAnEvent(\"readystatechange\", xhr);\n}\n\nfunction receiveResponse(xhr, response, currentURL) {\n  const { flag, properties } = xhr;\n  const { rawHeaders, statusCode } = response;\n\n  let byteOffset = 0;\n\n  const headers = {};\n  const filteredResponseHeaders = [];\n  const headerMap = {};\n  const n = Number(rawHeaders.length);\n  for (let i = 0; i < n; i += 2) {\n    const k = rawHeaders[i];\n    const kl = k.toLowerCase();\n    const v = rawHeaders[i + 1];\n    if (uniqueResponseHeaders.has(kl)) {\n      if (headerMap[kl] !== undefined) {\n        delete headers[headerMap[kl]];\n      }\n      headers[k] = v;\n    } else if (headerMap[kl] !== undefined) {\n      headers[headerMap[kl]] += \", \" + v;\n    } else {\n      headers[k] = v;\n    }\n    headerMap[kl] = k;\n  }\n\n  const destUrlObj = new URL(currentURL);\n  if (properties.origin !== destUrlObj.origin &&\n      destUrlObj.protocol !== \"data:\") {\n    if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n      return;\n    }\n    const acehStr = response.headers[\"access-control-expose-headers\"];\n    const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n      if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n  }\n\n  for (const header in headers) {\n    const lcHeader = header.toLowerCase();\n    if (forbiddenResponseHeaders.has(lcHeader)) {\n      filteredResponseHeaders.push(header);\n    }\n  }\n\n  xhr.responseURL = destUrlObj.href;\n\n  xhr.status = statusCode;\n  xhr.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n\n  properties.responseHeaders = headers;\n  properties.filteredResponseHeaders = filteredResponseHeaders;\n\n  const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n  const bufferLength = parseInt(contentLength) || 0;\n  const progressObj = { lengthComputable: false };\n  let lastProgressReported;\n  if (bufferLength !== 0) {\n    progressObj.total = bufferLength;\n    progressObj.loaded = 0;\n    progressObj.lengthComputable = true;\n  }\n  // pre-allocate buffer.\n  properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n  properties.responseCache = null;\n  properties.responseTextCache = null;\n  properties.responseXMLCache = null;\n  readyStateChange(xhr, READY_STATES.HEADERS_RECEIVED);\n\n  if (!properties.client) {\n    // The request was aborted in reaction to the readystatechange event.\n    return;\n  }\n\n  // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n  // Content-Length).\n  response.on(\"data\", chunk => {\n    byteOffset += chunk.length;\n    progressObj.loaded = byteOffset;\n  });\n\n  properties.client.on(\"data\", chunk => {\n    properties.totalReceivedChunkSize += chunk.length;\n    if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n      properties.bufferStepSize *= 2;\n      while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n      }\n      const tmpBuf = Buffer.alloc(properties.bufferStepSize);\n      properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n      properties.responseBuffer = tmpBuf;\n    }\n    chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n\n    if (xhr.readyState === READY_STATES.HEADERS_RECEIVED) {\n      xhr.readyState = READY_STATES.LOADING;\n    }\n    fireAnEvent(\"readystatechange\", xhr);\n\n    if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n      if (lastProgressReported !== progressObj.loaded) {\n        // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n        // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n        lastProgressReported = progressObj.loaded;\n        fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n      }\n    }\n  });\n  properties.client.on(\"end\", () => {\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    properties.client = null;\n    if (lastProgressReported !== progressObj.loaded) {\n      // https://github.com/whatwg/xhr/issues/318\n      fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n    }\n    readyStateChange(xhr, READY_STATES.DONE);\n    fireAnEvent(\"load\", xhr, ProgressEvent, progressObj);\n    fireAnEvent(\"loadend\", xhr, ProgressEvent, progressObj);\n  });\n}\n\nfunction setDispatchProgressEvents(xhr) {\n  const { properties, upload } = xhr;\n  const { client } = properties;\n\n  let total = 0;\n  let lengthComputable = false;\n  const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n  if (length) {\n    total = length;\n    lengthComputable = true;\n  }\n  const initProgress = {\n    lengthComputable,\n    total,\n    loaded: 0\n  };\n\n  if (properties.uploadListener) {\n    fireAnEvent(\"loadstart\", upload, ProgressEvent, initProgress);\n  }\n\n  client.on(\"request\", req => {\n    req.on(\"response\", () => {\n      properties.uploadComplete = true;\n\n      if (!properties.uploadListener) {\n        return;\n      }\n\n      const progress = {\n        lengthComputable,\n        total,\n        loaded: total\n      };\n      fireAnEvent(\"progress\", upload, ProgressEvent, progress);\n      fireAnEvent(\"load\", upload, ProgressEvent, progress);\n      fireAnEvent(\"loadend\", upload, ProgressEvent, progress);\n    });\n  });\n}\n\nfunction finalMIMEType(xhr) {\n  const { flag } = xhr;\n  return flag.overrideMIMEType || getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  const { flag } = xhr;\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n  const parsedContentType = MIMEType.parse(getResponseHeader(xhr, \"content-type\"));\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n  return null;\n}\n\nfunction getResponseHeader(xhr, lcHeader) {\n  const { properties } = xhr;\n  const keys = Object.keys(properties.responseHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (isArrayBuffer(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    const formData = [];\n    for (const entry of bodyInit._entries) {\n      let val;\n      if (Blob.isImpl(entry.value)) {\n        const blob = entry.value;\n        val = {\n          name: entry.name,\n          value: blob._buffer,\n          options: {\n            filename: blob.name,\n            contentType: blob.type,\n            knownLength: blob.size\n          }\n        };\n      } else {\n        val = entry;\n      }\n\n      formData.push(val);\n    }\n\n    return { formData };\n  }\n\n  // Must be a string\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}\n\nexports.implementation = XMLHttpRequestImpl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}