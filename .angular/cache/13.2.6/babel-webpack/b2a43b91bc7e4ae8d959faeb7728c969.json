{"ast":null,"code":"import _asyncToGenerator from \"/home/dove/Documents/tchek/AnnotationOSD/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport class AnnotationOSDService {\n  constructor(debug = false) {\n    this.DEBUG = debug;\n  }\n  playerFactory(type, id, link) {\n    return new Promise(resolve => {\n      this.viewer = OpenSeadragon({\n        id,\n        tileSources: type === 'dzi' ? link : {\n          type: 'image',\n          url: link\n        },\n        gestureSettingsTouch: {\n          pinchRotate: false\n        },\n        showRotationControl: false,\n        showNavigationControl: false,\n        showFlipControl: false,\n        zoomPerClick: 1,\n        imageLoaderLimit: 1,\n        constrainDuringPan: true,\n        debugMode: this.DEBUG\n      });\n      const subjectZoom = new Subject();\n      this.viewer.addHandler('zoom', e => {\n        subjectZoom.next(e);\n      });\n      subjectZoom.pipe(debounceTime(50)).subscribe(() => {\n        this.calculateRatio();\n        this.resetStrokeWidth();\n      });\n      this.viewer.addOnceHandler('open', () => {\n        console.log('open');\n        this.calculateRatio();\n        resolve(this);\n      });\n      const subjectResize = new Subject();\n      this.viewer.addHandler('resize', e => {\n        subjectResize.next(e);\n      });\n      subjectResize.pipe(debounceTime(200)).subscribe(() => {\n        this.goHome();\n      });\n    });\n  }\n  setHome(point, width, height) {\n    const homePoint = this.viewer.viewport.imageToViewerElementCoordinates(new OpenSeadragon.Point(this.imageWidth / 2, this.imageHeight / 2));\n    const w = this.imageWidth / width;\n    const h = this.imageHeight / height;\n    const zoom = 4; // w > h ? h : w;\n    console.log(homePoint, zoom, this.imageWidth, this.imageHeight);\n    this.viewer.viewport.zoomTo(1.2, homePoint, false);\n    return this;\n  }\n  /**\n   * Auto reset the size of fabric elements when user zoom on canvas, or page resize.\n   * @private\n   */\n  resetStrokeWidth() {\n    if (this.canvas) {\n      const w = 2; // desired width in pixels\n      const strokeWidth = w / this.canvas.getZoom();\n      for (const object of this.canvas.getObjects()) {\n        object.set('strokeUniform', true);\n        object.set('strokeWidth', strokeWidth);\n        // @ts-ignore\n        if (object.get('radius')) {\n          // @ts-ignore\n          object.set('radius', 5 / this.canvas.getZoom());\n        }\n        // can also update other things here\n      }\n    }\n  }\n  /**\n   * Calculate ratio of canvas when user load image or resize page.\n   * @private\n   */\n  calculateRatio() {\n    this.imageWidth = this.viewer.source.dimensions.x;\n    this.imageHeight = this.viewer.dimensions.y;\n    this.containerWidth = this.viewer.viewport.getContainerSize().x;\n    this.containerHeight = this.viewer.viewport.getContainerSize().y;\n    this.zoomToZoomLevelRatio = this.containerWidth / this.imageWidth;\n    this.scale = this.viewer.viewport.getZoom(true) * this.zoomToZoomLevelRatio;\n  }\n  goHome() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.viewer.viewport.goHome(false);\n      return _this;\n    })();\n  }\n  /* public addCanvas() {\n      this.canvas = (this.viewer as any)\n          .fabricjsOverlay({ scale: 1000 })\n          .fabricCanvas();\n      return this;\n  }\n   public addDamage(damage : MarkerRound | MarkerRect | MarkerPoly) {\n      const poly = new fabric.Polygon([\n          {x: 200, y: 10},\n          {x: 250, y: 50},\n          {x: 250, y: 180},\n          {x: 150, y: 180},\n          {x: 150, y: 50}], {\n          fill: 'green',\n          opacity: 0.3,\n      });\n       this.canvas.add(poly);\n   }\n  min = 99;\n  max = 999999;\n  polygonMode = true;\n  pointArray = [];\n  lineArray = [];\n  activeLine;\n  activeShape ;\n   public addDamage(damage : MarkerRound | MarkerRect | MarkerPoly) {\n  const strokeWidth = 2;\n  let obj;\n  if (!(damage instanceof MarkerPoly)) {\n  obj = new fabric.Rect({\n  id: 1,\n  left: (damage.unit === 'percent' ? damage.centerX * (this.imageWidth * this.scale)\n  : damage.centerX * this.scale) + strokeWidth,\n  top: (damage.unit === 'percent' ? damage.centerY * (this.imageHeight * this.scale)\n  : damage.centerY * this.scale) + strokeWidth,\n  width: (damage.unit === 'percent' ? damage.width * (this.imageWidth * this.scale)\n  : damage.width * this.scale),\n  height: (damage.unit === 'percent' ? damage.height * (this.imageHeight * this.scale)\n  : damage.height * this.scale),\n  strokeWidth,\n  strokeUniform: true,\n  strokeDashArray: undefined,\n  originX: 'center',\n  originY: 'center',\n  cornerStyle: 'circle',\n  // Add data option for style settings\n  fill: 'transparent',\n  stroke: 'red',\n  selectable: true,\n  hasBorders: false,\n  cornerColor: 'red',\n  transparentCorners: false,\n  draggable: true,\n  lockRotation: true,\n  hasControls: true,\n  });\n  }\n  obj.set('strokeUniform', true);\n  obj.setControlsVisibility({ mtr: false });\n  this.canvas.add(obj);\n  const poly = new fabric.Polygon([\n  { x: 200, y: 10 },\n  { x: 250, y: 50 },\n  { x: 250, y: 180 },\n  { x: 150, y: 180 },\n  { x: 150, y: 50 }], {\n    fill: 'green',\n        opacity: 0.3,\n        });\n  this.canvas.add(poly);\n  // this.canvas.on('mouse:down', (options) => {\n  //     if (options.target && options.target.id === this.pointArray[0].id) {\n  //         this.generatePolygon(this.pointArray);\n  //     }\n  //     if (this.polygonMode) {\n  //         this.addPoint(options);\n  //     }\n  // });\n  // this.canvas.on('mouse:up', (options) => {\n  //\n  // });\n  // this.canvas.on('mouse:move', (options) => {\n  //     if (this.activeLine && this.activeLine.class === 'line') {\n  //         const pointer = this.canvas.getPointer(options.e);\n  //         this.activeLine.set({ x2: pointer.x, y2: pointer.y });\n  //\n  //         const points = this.activeShape.get('points');\n  //         points[this.pointArray.length] = {\n  //             x: pointer.x,\n  //             y: pointer.y,\n  //         };\n  //         this.activeShape.set({\n  //             points,\n  //         });\n  //         this.canvas.renderAll();\n  //     }\n  //     this.canvas.renderAll();\n  // });\n  /!*        this.canvas.on('object:scaling', (e) => {\n  console.log('scalling ');\n  this.resetStrokeWidth();\n  }); *!/\n  return this;\n  }\n  private drawPolygon() {\n  this.polygonMode = true;\n  this.pointArray = [];\n  this.lineArray = [];\n  this.activeLine;\n  }\n  private addPoint(options) {\n  console.log(options);\n  const random = Math.floor(Math.random() * (this.max - this.min + 1)) + this.min;\n  const id = new Date().getTime() + random;\n  const pos = this.canvas.getPointer(options.e);\n  const circle = new fabric.Circle({\n  radius: 5 / this.canvas.getZoom(),\n  fill: '#ffffff',\n  stroke: '#333333',\n  strokeWidth: 0.5,\n  left: pos.x,\n  top: pos.y,\n  selectable: false,\n  hasBorders: false,\n  hasControls: false,\n  originX: 'center',\n  originY: 'center',\n  id,\n  objectCaching: false,\n  });\n  if (this.pointArray.length === 0) {\n  circle.set({\n  fill: 'red',\n  });\n  }\n  const pointsA = [pos.x, pos.y, pos.x, pos.y];\n  const line = new fabric.Line(pointsA, {\n  strokeWidth: 2,\n  fill: '#999999',\n  stroke: '#999999',\n  class: 'line',\n  originX: 'center',\n  originY: 'center',\n  selectable: false,\n  hasBorders: false,\n  hasControls: false,\n  evented: false,\n  objectCaching: false,\n  });\n  console.log(this.activeShape);\n  if (this.activeShape) {\n    const pointsB = this.activeShape.get('points') as any[];\n        pointsB.push({\n            x: pos.x,\n            y: pos.y,\n        });\n        const polygonA = new fabric.Polygon(pointsB, {\n    stroke: '#333333',\n    strokeWidth: 1,\n    fill: '#cccccc',\n    opacity: 0.3,\n    selectable: false,\n    hasBorders: false,\n    hasControls: false,\n    evented: false,\n    objectCaching: false,\n  });\n  this.canvas.remove(this.activeShape);\n  this.canvas.add(polygonA);\n  this.activeShape = polygonA;\n  this.canvas.renderAll();\n  } else {\n  const polyPoint = [{ x: pos.x, y: pos.y }];\n  const polygon = new fabric.Polygon(polyPoint, {\n        stroke: '#333333',\n                strokeWidth: 1,\n                fill: '#cccccc',\n                opacity: 0.3,\n                selectable: false,\n                hasBorders: false,\n                hasControls: false,\n                evented: false,\n                objectCaching: false,\n        });\n        this.activeShape = polygon;\n        this.canvas.add(polygon);\n        }\n  this.activeLine = line;\n  this.pointArray.push(circle);\n  this.lineArray.push(line);\n  this.canvas.add(line);\n  this.canvas.add(circle);\n  }\n  private generatePolygon(pointArray) {\n  console.log(pointArray, this.lineArray);\n  const points = [];\n  pointArray.forEach((point) => {\n  points.push({\n  x: point.left,\n  y: point.top,\n  });\n  this.canvas.remove(point);\n  });\n  this.lineArray.forEach((line) => {\n  this.canvas.remove(line);\n  });\n  this.canvas.remove(this.activeShape).remove(this.activeLine);\n  const polygon = new fabric.Polygon(points, {\n  stroke: '#333333',\n  strokeWidth: 0.5,\n  opacity: 0.3,\n  fill: 'red',\n  hasBorders: false,\n  hasControls: false,\n  });\n  this.canvas.add(polygon);\n  this.activeLine = null;\n  this.activeShape = null;\n  this.polygonMode = false;\n  }\n  */\n  delete() {\n    this.canvas.clear();\n    this.canvas.dispose();\n    this.canvas.removeListeners();\n    this.viewer.destroy();\n  }\n}\nAnnotationOSDService.ɵfac = function AnnotationOSDService_Factory(t) {\n  return new (t || AnnotationOSDService)(i0.ɵɵinject(Boolean));\n};\nAnnotationOSDService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AnnotationOSDService,\n  factory: AnnotationOSDService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Subject","debounceTime","i0","AnnotationOSDService","constructor","debug","DEBUG","playerFactory","type","id","link","Promise","resolve","viewer","OpenSeadragon","tileSources","url","gestureSettingsTouch","pinchRotate","showRotationControl","showNavigationControl","showFlipControl","zoomPerClick","imageLoaderLimit","constrainDuringPan","debugMode","subjectZoom","addHandler","e","next","pipe","subscribe","calculateRatio","resetStrokeWidth","addOnceHandler","console","log","subjectResize","goHome","setHome","point","width","height","homePoint","viewport","imageToViewerElementCoordinates","Point","imageWidth","imageHeight","w","h","zoom","zoomTo","canvas","strokeWidth","getZoom","object","getObjects","set","get","source","dimensions","x","y","containerWidth","getContainerSize","containerHeight","zoomToZoomLevelRatio","scale","delete","clear","dispose","removeListeners","destroy","ɵfac","AnnotationOSDService_Factory","t","ɵɵinject","Boolean","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"sources":["/home/dove/Documents/tchek/AnnotationOSD/projects/annotation-osd/src/lib/annotation-osd.service.ts"],"sourcesContent":["import { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport class AnnotationOSDService {\n    constructor(debug = false) {\n        this.DEBUG = debug;\n    }\n    playerFactory(type, id, link) {\n        return new Promise((resolve) => {\n            this.viewer = OpenSeadragon({\n                id,\n                tileSources: type === 'dzi' ? link : { type: 'image', url: link },\n                gestureSettingsTouch: { pinchRotate: false },\n                showRotationControl: false,\n                showNavigationControl: false,\n                showFlipControl: false,\n                zoomPerClick: 1,\n                imageLoaderLimit: 1,\n                constrainDuringPan: true,\n                debugMode: this.DEBUG,\n            });\n            const subjectZoom = new Subject();\n            this.viewer.addHandler('zoom', (e) => {\n                subjectZoom.next(e);\n            });\n            subjectZoom.pipe(debounceTime(50)).subscribe(() => {\n                this.calculateRatio();\n                this.resetStrokeWidth();\n            });\n            this.viewer.addOnceHandler('open', () => {\n                console.log('open');\n                this.calculateRatio();\n                resolve(this);\n            });\n            const subjectResize = new Subject();\n            this.viewer.addHandler('resize', (e) => {\n                subjectResize.next(e);\n            });\n            subjectResize.pipe(debounceTime(200)).subscribe(() => {\n                this.goHome();\n            });\n        });\n    }\n    setHome(point, width, height) {\n        const homePoint = this.viewer.viewport.imageToViewerElementCoordinates(new OpenSeadragon.Point(this.imageWidth / 2, this.imageHeight / 2));\n        const w = this.imageWidth / width;\n        const h = this.imageHeight / height;\n        const zoom = 4; // w > h ? h : w;\n        console.log(homePoint, zoom, this.imageWidth, this.imageHeight);\n        this.viewer.viewport.zoomTo(1.2, homePoint, false);\n        return this;\n    }\n    /**\n     * Auto reset the size of fabric elements when user zoom on canvas, or page resize.\n     * @private\n     */\n    resetStrokeWidth() {\n        if (this.canvas) {\n            const w = 2; // desired width in pixels\n            const strokeWidth = w / this.canvas.getZoom();\n            for (const object of this.canvas.getObjects()) {\n                object.set('strokeUniform', true);\n                object.set('strokeWidth', strokeWidth);\n                // @ts-ignore\n                if (object.get('radius')) {\n                    // @ts-ignore\n                    object.set('radius', 5 / this.canvas.getZoom());\n                }\n                // can also update other things here\n            }\n        }\n    }\n    /**\n     * Calculate ratio of canvas when user load image or resize page.\n     * @private\n     */\n    calculateRatio() {\n        this.imageWidth = this.viewer.source.dimensions.x;\n        this.imageHeight = this.viewer.dimensions.y;\n        this.containerWidth = this.viewer.viewport.getContainerSize().x;\n        this.containerHeight = this.viewer.viewport.getContainerSize().y;\n        this.zoomToZoomLevelRatio = this.containerWidth / this.imageWidth;\n        this.scale = this.viewer.viewport.getZoom(true) * this.zoomToZoomLevelRatio;\n    }\n    async goHome() {\n        this.viewer.viewport.goHome(false);\n        return this;\n    }\n    /* public addCanvas() {\n        this.canvas = (this.viewer as any)\n            .fabricjsOverlay({ scale: 1000 })\n            .fabricCanvas();\n        return this;\n    }\n\n    public addDamage(damage : MarkerRound | MarkerRect | MarkerPoly) {\n        const poly = new fabric.Polygon([\n            {x: 200, y: 10},\n            {x: 250, y: 50},\n            {x: 250, y: 180},\n            {x: 150, y: 180},\n            {x: 150, y: 50}], {\n            fill: 'green',\n            opacity: 0.3,\n        });\n\n        this.canvas.add(poly);\n\n    }\n    min = 99;\n    max = 999999;\n    polygonMode = true;\n    pointArray = [];\n    lineArray = [];\n    activeLine;\n    activeShape ;\n\n    public addDamage(damage : MarkerRound | MarkerRect | MarkerPoly) {\n  const strokeWidth = 2;\n  let obj;\n  if (!(damage instanceof MarkerPoly)) {\n  obj = new fabric.Rect({\n  id: 1,\n  left: (damage.unit === 'percent' ? damage.centerX * (this.imageWidth * this.scale)\n  : damage.centerX * this.scale) + strokeWidth,\n  top: (damage.unit === 'percent' ? damage.centerY * (this.imageHeight * this.scale)\n  : damage.centerY * this.scale) + strokeWidth,\n  width: (damage.unit === 'percent' ? damage.width * (this.imageWidth * this.scale)\n  : damage.width * this.scale),\n  height: (damage.unit === 'percent' ? damage.height * (this.imageHeight * this.scale)\n  : damage.height * this.scale),\n  strokeWidth,\n  strokeUniform: true,\n  strokeDashArray: undefined,\n  originX: 'center',\n  originY: 'center',\n  cornerStyle: 'circle',\n\n  // Add data option for style settings\n  fill: 'transparent',\n  stroke: 'red',\n  selectable: true,\n  hasBorders: false,\n  cornerColor: 'red',\n  transparentCorners: false,\n  draggable: true,\n  lockRotation: true,\n  hasControls: true,\n\n  });\n  }\n  obj.set('strokeUniform', true);\n\n  obj.setControlsVisibility({ mtr: false });\n  this.canvas.add(obj);\n\n  const poly = new fabric.Polygon([\n  { x: 200, y: 10 },\n  { x: 250, y: 50 },\n  { x: 250, y: 180 },\n  { x: 150, y: 180 },\n  { x: 150, y: 50 }], {\n      fill: 'green',\n          opacity: 0.3,\n          });\n\n  this.canvas.add(poly);\n\n  // this.canvas.on('mouse:down', (options) => {\n  //     if (options.target && options.target.id === this.pointArray[0].id) {\n  //         this.generatePolygon(this.pointArray);\n  //     }\n  //     if (this.polygonMode) {\n  //         this.addPoint(options);\n  //     }\n  // });\n  // this.canvas.on('mouse:up', (options) => {\n  //\n  // });\n  // this.canvas.on('mouse:move', (options) => {\n  //     if (this.activeLine && this.activeLine.class === 'line') {\n  //         const pointer = this.canvas.getPointer(options.e);\n  //         this.activeLine.set({ x2: pointer.x, y2: pointer.y });\n  //\n  //         const points = this.activeShape.get('points');\n  //         points[this.pointArray.length] = {\n  //             x: pointer.x,\n  //             y: pointer.y,\n  //         };\n  //         this.activeShape.set({\n  //             points,\n  //         });\n  //         this.canvas.renderAll();\n  //     }\n  //     this.canvas.renderAll();\n  // });\n\n  /!*        this.canvas.on('object:scaling', (e) => {\n  console.log('scalling ');\n  this.resetStrokeWidth();\n  }); *!/\n  return this;\n  }\n\n  private drawPolygon() {\n  this.polygonMode = true;\n  this.pointArray = [];\n  this.lineArray = [];\n  this.activeLine;\n  }\n\n  private addPoint(options) {\n  console.log(options);\n  const random = Math.floor(Math.random() * (this.max - this.min + 1)) + this.min;\n  const id = new Date().getTime() + random;\n  const pos = this.canvas.getPointer(options.e);\n  const circle = new fabric.Circle({\n  radius: 5 / this.canvas.getZoom(),\n  fill: '#ffffff',\n  stroke: '#333333',\n  strokeWidth: 0.5,\n  left: pos.x,\n  top: pos.y,\n  selectable: false,\n  hasBorders: false,\n  hasControls: false,\n  originX: 'center',\n  originY: 'center',\n  id,\n  objectCaching: false,\n  });\n  if (this.pointArray.length === 0) {\n  circle.set({\n  fill: 'red',\n  });\n  }\n  const pointsA = [pos.x, pos.y, pos.x, pos.y];\n  const line = new fabric.Line(pointsA, {\n  strokeWidth: 2,\n  fill: '#999999',\n  stroke: '#999999',\n  class: 'line',\n  originX: 'center',\n  originY: 'center',\n  selectable: false,\n  hasBorders: false,\n  hasControls: false,\n  evented: false,\n  objectCaching: false,\n  });\n  console.log(this.activeShape);\n  if (this.activeShape) {\n      const pointsB = this.activeShape.get('points') as any[];\n          pointsB.push({\n              x: pos.x,\n              y: pos.y,\n          });\n          const polygonA = new fabric.Polygon(pointsB, {\n      stroke: '#333333',\n      strokeWidth: 1,\n      fill: '#cccccc',\n      opacity: 0.3,\n      selectable: false,\n      hasBorders: false,\n      hasControls: false,\n      evented: false,\n      objectCaching: false,\n    });\n    this.canvas.remove(this.activeShape);\n    this.canvas.add(polygonA);\n    this.activeShape = polygonA;\n    this.canvas.renderAll();\n  } else {\n    const polyPoint = [{ x: pos.x, y: pos.y }];\n    const polygon = new fabric.Polygon(polyPoint, {\n          stroke: '#333333',\n                  strokeWidth: 1,\n                  fill: '#cccccc',\n                  opacity: 0.3,\n                  selectable: false,\n                  hasBorders: false,\n                  hasControls: false,\n                  evented: false,\n                  objectCaching: false,\n          });\n          this.activeShape = polygon;\n          this.canvas.add(polygon);\n          }\n  this.activeLine = line;\n\n  this.pointArray.push(circle);\n  this.lineArray.push(line);\n\n  this.canvas.add(line);\n  this.canvas.add(circle);\n  }\n\n  private generatePolygon(pointArray) {\n  console.log(pointArray, this.lineArray);\n  const points = [];\n  pointArray.forEach((point) => {\n  points.push({\n  x: point.left,\n  y: point.top,\n  });\n    this.canvas.remove(point);\n  });\n  this.lineArray.forEach((line) => {\n  this.canvas.remove(line);\n  });\n  this.canvas.remove(this.activeShape).remove(this.activeLine);\n  const polygon = new fabric.Polygon(points, {\n  stroke: '#333333',\n  strokeWidth: 0.5,\n  opacity: 0.3,\n  fill: 'red',\n  hasBorders: false,\n  hasControls: false,\n  });\n  this.canvas.add(polygon);\n\n  this.activeLine = null;\n  this.activeShape = null;\n  this.polygonMode = false;\n  }\n*/\n    delete() {\n        this.canvas.clear();\n        this.canvas.dispose();\n        this.canvas.removeListeners();\n        this.viewer.destroy();\n    }\n}\nAnnotationOSDService.ɵfac = function AnnotationOSDService_Factory(t) { return new (t || AnnotationOSDService)(i0.ɵɵinject(Boolean)); };\nAnnotationOSDService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AnnotationOSDService, factory: AnnotationOSDService.ɵfac, providedIn: 'root' });\n"],"mappings":"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AACL,MAAM,CAACE,OAAO,EAAE,CAAC;QACnD;QACA;MACJ;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACIvB,cAAc,GAAG;IACb,IAAI,CAACe,UAAU,GAAG,IAAI,CAAClC,MAAM,CAAC+C,MAAM,CAACC,UAAU,CAACC,CAAC;IACjD,IAAI,CAACd,WAAW,GAAG,IAAI,CAACnC,MAAM,CAACgD,UAAU,CAACE,CAAC;IAC3C,IAAI,CAACC,cAAc,GAAG,IAAI,CAACnD,MAAM,CAAC+B,QAAQ,CAACqB,gBAAgB,EAAE,CAACH,CAAC;IAC/D,IAAI,CAACI,eAAe,GAAG,IAAI,CAACrD,MAAM,CAAC+B,QAAQ,CAACqB,gBAAgB,EAAE,CAACF,CAAC;IAChE,IAAI,CAACI,oBAAoB,GAAG,IAAI,CAACH,cAAc,GAAG,IAAI,CAACjB,UAAU;IACjE,IAAI,CAACqB,KAAK,GAAG,IAAI,CAACvD,MAAM,CAAC+B,QAAQ,CAACW,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAACY,oBAAoB;EAC/E;EACM7B,MAAM,GAAG;IAAA;IAAA;MACX,KAAI,CAACzB,MAAM,CAAC+B,QAAQ,CAACN,MAAM,CAAC,KAAK,CAAC;MAClC,OAAO,KAAI;IAAC;EAChB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAkBI+B,MAAM,GAAG;IACL,IAAI,CAAChB,MAAM,CAACiB,KAAK,EAAE;IACnB,IAAI,CAACjB,MAAM,CAACkB,OAAO,EAAE;IACrB,IAAI,CAAClB,MAAM,CAACmB,eAAe,EAAE;IAC7B,IAAI,CAAC3D,MAAM,CAAC4D,OAAO,EAAE;EACzB;AACJ;AACAtE,oBAAoB,CAACuE,IAAI,GAAG,SAASC,4BAA4B,CAACC,CAAC,EAAE;EAAE,OAAO,KAAKA,CAAC,IAAIzE,oBAAoB,EAAED,EAAE,CAAC2E,QAAQ,CAACC,OAAO,CAAC,CAAC;AAAE,CAAC;AACtI3E,oBAAoB,CAAC4E,KAAK,GAAG,aAAc7E,EAAE,CAAC8E,kBAAkB,CAAC;EAAEC,KAAK,EAAE9E,oBAAoB;EAAE+E,OAAO,EAAE/E,oBAAoB,CAACuE,IAAI;EAAES,UAAU,EAAE;AAAO,CAAC,CAAC"},"metadata":{},"sourceType":"module"}